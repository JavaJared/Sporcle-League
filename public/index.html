<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sporcle League</title>

    <!-- Bootstrap -->
    <!-- In <head>, replace your existing Bootstrap link -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootswatch@5/dist/minty/bootstrap.min.css"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="styles.css" />

    <style>
      /* small polish so Bootstrap themes apply everywhere */
      html,
      body {
        height: 100%;
      }
      body {
        background: var(--bs-body-bg);
        color: var(--bs-body-color);
      }
      .card {
        border-radius: 12px;
      }
      .card .card-body {
        padding: 16px;
      }
      .table td,
      .table th {
        vertical-align: middle;
      }
      .note {
        opacity: 0.7;
      }
      /* Playoff Bracket Styles */
      .playoff-bracket {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 40px;
        overflow-x: auto;
        padding: 20px;
      }

      .bracket-round {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        min-width: 200px;
        flex-shrink: 0;
      }

      .bracket-round-title {
        text-align: center;
        font-weight: bold;
        margin-bottom: 15px;
        font-size: 0.9rem;
        text-transform: uppercase;
        color: var(--bs-secondary);
      }

      .bracket-match {
        background: var(--bs-card-bg);
        border: 2px solid var(--bs-border-color);
        border-radius: 8px;
        margin: 10px 0;
        padding: 8px;
        position: relative;
      }

      .bracket-match.completed {
        border-color: var(--bs-success);
      }

      .bracket-match.active {
        border-color: var(--bs-primary);
        box-shadow: 0 0 10px rgba(13, 110, 253, 0.3);
      }

      .bracket-player {
        padding: 8px;
        margin: 2px 0;
        border-radius: 4px;
        background: var(--bs-body-bg);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
      }

      .bracket-player.winner {
        background: var(--bs-success);
        color: white;
        font-weight: bold;
      }

      .bracket-player.loser {
        opacity: 0.5;
      }

      .bracket-player.tbd {
        font-style: italic;
        opacity: 0.6;
      }

      .bracket-seed {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-right: 5px;
      }

      .bracket-connector {
        position: absolute;
        right: -40px;
        top: 50%;
        width: 40px;
        height: 2px;
        background: var(--bs-border-color);
        transform: translateY(-50%);
      }

      /* ========== Champion Badge Styles ========== */
      .champion-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.85rem;
        padding: 0.1em 0.3em;
        margin-left: 0.3em;
        border-radius: 4px;
        font-weight: 600;
        vertical-align: middle;
      }

      /* Commissioner's Trophy - Gold */
      .champion-badge.badge-commissioner {
        background: linear-gradient(135deg, #ffd700, #ffec8b);
        box-shadow: 0 1px 3px rgba(255, 215, 0, 0.4);
      }

      /* Sporcle Cup - Silver */
      .champion-badge.badge-cup {
        background: linear-gradient(135deg, #c0c0c0, #e8e8e8);
        box-shadow: 0 1px 3px rgba(192, 192, 192, 0.4);
      }

      /* Head to Head Demon - Red */
      .champion-badge.badge-h2h {
        background: linear-gradient(135deg, #ff6b6b, #ffa8a8);
        box-shadow: 0 1px 3px rgba(255, 107, 107, 0.4);
      }

      /* Highest Highs - Green */
      .champion-badge.badge-highs {
        background: linear-gradient(135deg, #51cf66, #8ce99a);
        box-shadow: 0 1px 3px rgba(81, 207, 102, 0.4);
      }

      /* ========== Hall of Champions Award Cards ========== */
      .award-card {
        background: linear-gradient(145deg, #1a1a2e, #16213e);
        border-radius: 16px;
        padding: 1.5rem;
        text-align: center;
        border: 2px solid transparent;
        transition: transform 0.2s, box-shadow 0.2s;
        height: 100%;
      }

      .award-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      .award-card.commissioners-trophy {
        border-color: #ffd700;
        background: linear-gradient(145deg, #2a2a1e, #1e1a10);
      }

      .award-card.sporcle-cup {
        border-color: #c0c0c0;
        background: linear-gradient(145deg, #1e1e2a, #15152a);
      }

      .award-card.h2h-demon {
        border-color: #ff4444;
        background: linear-gradient(145deg, #2a1a1a, #1e1010);
      }

      .award-card.highest-highs {
        border-color: #44ff44;
        background: linear-gradient(145deg, #1a2a1a, #101e10);
      }

      .award-icon {
        font-size: 3.5rem;
        margin-bottom: 0.75rem;
        display: block;
      }

      .award-title {
        font-size: 1.1rem;
        font-weight: 700;
        margin-bottom: 0.25rem;
        color: #fff;
      }

      .award-description {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-bottom: 1rem;
        line-height: 1.4;
      }

      .award-winner {
        font-size: 1.25rem;
        font-weight: 600;
        color: #fff;
        margin-bottom: 0.25rem;
      }

      .award-stat {
        font-size: 0.85rem;
        opacity: 0.8;
      }

      .award-card.commissioners-trophy .award-title {
        color: #ffd700;
      }
      .award-card.sporcle-cup .award-title {
        color: #c0c0c0;
      }
      .award-card.h2h-demon .award-title {
        color: #ff6b6b;
      }
      .award-card.highest-highs .award-title {
        color: #69db7c;
      }

      /* ========== Quiz Wheel Styles ========== */

      /* H2H Category Queue Buttons */
      .h2h-category-btn {
        transition: all 0.2s;
        border-width: 2px;
      }

      .h2h-category-btn.active {
        background-color: var(--bs-primary);
        border-color: var(--bs-primary);
        color: white;
        font-weight: 600;
      }

      .h2h-category-btn:not(.active):hover {
        background-color: rgba(var(--bs-primary-rgb), 0.1);
      }

      /* H2H Standings Pills */
      #h2h-standings-tabs .nav-link {
        padding: 0.4rem 0.75rem;
        font-size: 0.9rem;
      }
      .quiz-wheel-section {
        padding: 1.5rem;
      }

      .quiz-wheel-header {
        text-align: center;
        margin-bottom: 1rem;
      }

      .quiz-wheel-header h2 {
        font-size: 1.25rem;
        margin-bottom: 0.25rem;
      }

      .quiz-wheel-header p {
        font-size: 0.875rem;
        opacity: 0.7;
        margin: 0;
      }

      .wheel-and-result {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        gap: 2rem;
      }

      .wheel-area {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .wheel-wrapper {
        position: relative;
        width: 300px;
        height: 300px;
      }

      #wheel-canvas {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        box-shadow: 0 0 0 6px var(--bs-body-bg),
          0 0 0 10px var(--bs-border-color), 0 0 25px rgba(0, 0, 0, 0.3);
      }

      .wheel-center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60px;
        height: 60px;
        background: linear-gradient(
          145deg,
          var(--bs-card-bg),
          var(--bs-body-bg)
        );
        border-radius: 50%;
        box-shadow: 0 0 0 3px var(--bs-border-color),
          0 4px 12px rgba(0, 0, 0, 0.3),
          inset 0 2px 4px rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        font-size: 1.25rem;
      }

      .wheel-pointer {
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        filter: drop-shadow(0 3px 4px rgba(0, 0, 0, 0.3));
      }

      .wheel-pointer::before {
        content: "";
        display: block;
        width: 0;
        height: 0;
        border-left: 14px solid transparent;
        border-right: 14px solid transparent;
        border-top: 24px solid var(--bs-success);
      }

      .wheel-pointer::after {
        content: "";
        display: block;
        width: 14px;
        height: 14px;
        background: var(--bs-success);
        border-radius: 50%;
        margin: -7px auto 0;
      }

      .spin-button {
        margin-top: 1.25rem;
        padding: 0.75rem 2rem;
        font-size: 1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        background: linear-gradient(145deg, var(--bs-success), #198754);
        border: none;
        border-radius: 50px;
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(25, 135, 84, 0.4);
        transition: all 0.3s ease;
      }

      .spin-button:hover:not(:disabled) {
        transform: translateY(-2px) scale(1.03);
        box-shadow: 0 6px 20px rgba(25, 135, 84, 0.5);
      }

      .spin-button:active:not(:disabled) {
        transform: translateY(0) scale(0.98);
      }

      .spin-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      /* Today's Quiz Result Area */
      .todays-quiz-result {
        text-align: center;
        min-width: 280px;
        max-width: 380px;
        width: 100%;
      }

      .quiz-result-card {
        background: var(--bs-card-bg);
        border: 2px solid var(--bs-border-color);
        border-radius: 12px;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .quiz-result-card.has-quiz {
        border-color: var(--bs-success);
      }

      .quiz-result-header {
        padding: 1rem;
        color: white;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      .quiz-result-header.no-quiz {
        background: var(--bs-secondary);
      }

      .quiz-result-category {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        opacity: 0.9;
        margin-bottom: 0.25rem;
      }

      .quiz-result-title {
        font-size: 1.25rem;
        font-weight: 700;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
      }

      .quiz-result-body {
        padding: 1.25rem;
      }

      .quiz-name {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
      }

      .quiz-description {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-bottom: 1rem;
      }

      .quiz-play-link {
        display: inline-block;
        padding: 0.625rem 1.5rem;
        background: #2d3748;
        color: #fff !important;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.9rem;
        text-decoration: none;
        transition: all 0.3s ease;
        border: 2px solid var(--bs-success);
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .quiz-play-link:hover {
        background: var(--bs-success);
        color: #fff !important;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(25, 135, 84, 0.4);
      }

      .quiz-url-text {
        font-size: 0.75rem;
        color: var(--bs-secondary);
        margin-top: 0.75rem;
        margin-bottom: 0;
        word-break: break-all;
        opacity: 0.8;
      }

      /* Wheel spinning state */
      .wheel-wrapper.is-spinning #wheel-canvas {
        /* Animation applied via JS */
      }

      /* Waiting for spin state */
      .waiting-for-spin {
        animation: pulse-opacity 2s ease-in-out infinite;
      }

      @keyframes pulse-opacity {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      /* Category colors for result header */
      .wheel-cat-geography {
        background: linear-gradient(135deg, #f85149, #da3633);
      }
      .wheel-cat-history {
        background: linear-gradient(135deg, #d29922, #b08800);
      }
      .wheel-cat-science {
        background: linear-gradient(135deg, #3fb950, #2ea043);
      }
      .wheel-cat-sports {
        background: linear-gradient(135deg, #58a6ff, #1f6feb);
      }
      .wheel-cat-entertainment {
        background: linear-gradient(135deg, #a371f7, #8957e5);
      }
      .wheel-cat-music {
        background: linear-gradient(135deg, #f778ba, #db61a2);
      }
      .wheel-cat-literature {
        background: linear-gradient(135deg, #79c0ff, #58a6ff);
      }
      .wheel-cat-misc {
        background: linear-gradient(135deg, #ffa657, #d29922);
      }

      /* Confetti */
      .wheel-confetti {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1100;
        overflow: hidden;
      }

      .wheel-confetti-piece {
        position: absolute;
        top: -20px;
        animation: wheelConfettiFall 3s ease-out forwards;
      }

      @keyframes wheelConfettiFall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(100vh) rotate(720deg);
          opacity: 0;
        }
      }

      /* Responsive */
      @media screen and (max-width: 700px) {
        .wheel-and-result {
          flex-direction: column;
        }
        .wheel-wrapper {
          width: 260px;
          height: 260px;
        }
        .wheel-center {
          width: 50px;
          height: 50px;
          font-size: 1rem;
        }
        .todays-quiz-result {
          width: 100%;
          max-width: none;
        }
      }
    </style>
    <!-- React for Playoff Bracket -->
    <script
      src="https://unpkg.com/react@18/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
      crossorigin
    ></script>
  </head>
  <body class="bg-body text-body">
    <!-- Header -->
    <header class="container my-2">
      <div class="d-flex flex-wrap align-items-center gap-2">
        <h1 class="m-0 flex-grow-1">Sporcle League</h1>
        <span id="status" class="badge text-bg-secondary">Ready</span>
        <button
          id="account-signout"
          class="btn btn-outline-danger btn-sm d-none"
        >
          Sign out
        </button>
      </div>
    </header>

    <main class="container">
      <!-- Confetti Container -->
      <div id="wheel-confetti" class="wheel-confetti"></div>

      <!-- Today's Quiz with Spinning Wheel -->
      <section class="card mb-3">
        <div class="quiz-wheel-section">
          <div class="quiz-wheel-header">
            <h2>üé° Today's Quiz</h2>
            <p>Spin the wheel to pick today's category!</p>
          </div>

          <div class="wheel-and-result">
            <!-- Wheel Area -->
            <div class="wheel-area">
              <div class="wheel-wrapper" id="wheel-wrapper">
                <div class="wheel-pointer"></div>
                <canvas id="wheel-canvas" width="300" height="300"></canvas>
                <div class="wheel-center">‚≠ê</div>
              </div>
              <!-- Admin-only spin button -->
              <button id="spin-btn" class="spin-button d-none">
                üé≤ Spin the Wheel!
              </button>
              <div
                id="spin-status"
                class="text-secondary mt-2"
                style="font-size: 0.85rem"
              ></div>
            </div>

            <!-- Today's Quiz Result -->
            <div class="todays-quiz-result">
              <div id="quiz-result-card" class="quiz-result-card">
                <div id="quiz-result-header" class="quiz-result-header no-quiz">
                  <p class="quiz-result-category">Today's Category</p>
                  <h3 id="quiz-result-title" class="quiz-result-title">
                    <span>‚ùì</span>
                    <span>Waiting...</span>
                  </h3>
                </div>
                <div class="quiz-result-body">
                  <p id="quiz-name" class="quiz-name">No quiz selected yet</p>
                  <p id="quiz-description" class="quiz-description">
                    Admin will spin the wheel to select today's quiz!
                  </p>
                  <a
                    id="quiz-link-display"
                    href="#"
                    target="_blank"
                    class="quiz-play-link d-none"
                  >
                    ‚ñ∂ Play This Quiz
                  </a>
                  <p id="quiz-url-display" class="quiz-url-text d-none"></p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- User Auth Modal -->
      <div
        class="modal fade"
        id="authModal"
        data-bs-backdrop="static"
        data-bs-keyboard="false"
        tabindex="-1"
      >
        <div class="modal-dialog modal-dialog-centered">
          <div
            class="modal-content"
            style="
              background-color: #212529;
              border-color: var(--bs-border-color);
            "
          >
            <div class="modal-header border-0">
              <h5 class="modal-title" id="authModalTitle">
                Welcome to Sporcle League!
              </h5>
            </div>
            <div class="modal-body">
              <!-- Sign In View -->
              <div id="auth-signin-view">
                <p class="text-muted mb-3">
                  Sign in to track your scores and compete with others.
                </p>
                <form id="signin-form">
                  <div class="mb-3">
                    <label for="signin-email" class="form-label">Email</label>
                    <input
                      type="email"
                      id="signin-email"
                      class="form-control"
                      placeholder="you@example.com"
                      required
                    />
                  </div>
                  <div class="mb-3">
                    <label for="signin-password" class="form-label"
                      >Password</label
                    >
                    <input
                      type="password"
                      id="signin-password"
                      class="form-control"
                      placeholder="Your password"
                      required
                    />
                  </div>
                  <button
                    type="submit"
                    id="signin-btn"
                    class="btn btn-primary w-100 mb-2"
                  >
                    Sign In
                  </button>
                </form>
                <div
                  id="signin-status"
                  class="form-text text-danger mb-2"
                ></div>
                <div class="text-center">
                  <span class="text-muted">Don't have an account?</span>
                  <button
                    type="button"
                    id="show-signup-btn"
                    class="btn btn-link p-0"
                  >
                    Sign Up
                  </button>
                </div>
              </div>

              <!-- Sign Up View -->
              <div id="auth-signup-view" class="d-none">
                <p class="text-muted mb-3">
                  Create an account to start competing.
                </p>
                <form id="signup-form">
                  <div class="mb-3">
                    <label for="signup-displayname" class="form-label"
                      >Display Name</label
                    >
                    <input
                      type="text"
                      id="signup-displayname"
                      class="form-control"
                      placeholder="John Smith"
                      required
                    />
                    <div class="form-text">Shown on leaderboards</div>
                  </div>
                  <div class="mb-3">
                    <label for="signup-alias" class="form-label">Alias</label>
                    <input
                      type="text"
                      id="signup-alias"
                      class="form-control"
                      placeholder="johnsmith"
                      required
                      pattern="[a-zA-Z0-9_]+"
                    />
                    <div class="form-text">
                      Unique identifier (letters, numbers, underscores only)
                    </div>
                  </div>
                  <div class="mb-3">
                    <label for="signup-email" class="form-label">Email</label>
                    <input
                      type="email"
                      id="signup-email"
                      class="form-control"
                      placeholder="you@example.com"
                      required
                    />
                  </div>
                  <div class="mb-3">
                    <label for="signup-password" class="form-label"
                      >Password</label
                    >
                    <input
                      type="password"
                      id="signup-password"
                      class="form-control"
                      placeholder="At least 6 characters"
                      required
                      minlength="6"
                    />
                  </div>
                  <button
                    type="submit"
                    id="signup-btn"
                    class="btn btn-primary w-100 mb-2"
                  >
                    Create Account
                  </button>
                </form>
                <div
                  id="signup-status"
                  class="form-text text-danger mb-2"
                ></div>
                <div class="text-center">
                  <span class="text-muted">Already have an account?</span>
                  <button
                    type="button"
                    id="show-signin-btn"
                    class="btn btn-link p-0"
                  >
                    Sign In
                  </button>
                </div>
              </div>

              <!-- Edit Profile View -->
              <div id="auth-profile-view" class="d-none">
                <p class="mb-3">Update your profile:</p>
                <form id="profile-setup-form">
                  <div class="mb-3">
                    <label for="setup-displayname" class="form-label"
                      >Display Name</label
                    >
                    <input
                      type="text"
                      id="setup-displayname"
                      class="form-control"
                      placeholder="John Smith"
                      required
                    />
                  </div>
                  <div class="mb-3">
                    <label for="setup-alias" class="form-label">Alias</label>
                    <input
                      type="text"
                      id="setup-alias"
                      class="form-control"
                      placeholder="johnsmith"
                      required
                      pattern="[a-zA-Z0-9_]+"
                    />
                    <div class="form-text">
                      Unique identifier (cannot be changed once set)
                    </div>
                  </div>
                  <button type="submit" class="btn btn-primary w-100">
                    Save Profile
                  </button>
                </form>
                <div
                  id="profile-setup-status"
                  class="form-text mt-2 text-danger"
                ></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- User Profile Bar (shown when logged in) -->
      <div
        id="user-profile-bar"
        class="d-none mb-3 p-3 rounded"
        style="
          background: var(--bs-card-bg);
          border: 1px solid var(--bs-border-color);
        "
      >
        <div
          class="d-flex justify-content-between align-items-center flex-wrap gap-2"
        >
          <div>
            <span class="text-muted">Signed in as:</span>
            <strong id="user-display-name">--</strong>
            <span class="text-muted">(<span id="user-alias">--</span>)</span>
          </div>
          <div class="d-flex gap-2">
            <button
              id="edit-profile-btn"
              class="btn btn-outline-secondary btn-sm"
            >
              Edit Profile
            </button>
            <button id="user-signout-btn" class="btn btn-outline-danger btn-sm">
              Sign Out
            </button>
          </div>
        </div>
      </div>

      <!-- Always visible: Submit Score (simplified for logged-in users) -->
      <section id="submit-score-section" class="card mb-3">
        <div class="card-body">
          <h2 class="h5 mb-3">Submit Score</h2>

          <!-- Shown when not logged in -->
          <div id="submit-guest-view">
            <p class="text-muted mb-3">Sign in to submit your score.</p>
            <button id="submit-signin-btn" class="btn btn-primary">
              Sign In
            </button>
          </div>

          <!-- Shown when logged in -->
          <div id="submit-user-view" class="d-none">
            <form id="entry-form" class="row g-2 align-items-end">
              <div class="col-sm-4">
                <label for="fraction" class="form-label">Score</label>
                <input
                  id="fraction"
                  class="form-control"
                  type="text"
                  placeholder="7/9"
                  required
                />
              </div>
              <div class="col-sm-4">
                <label for="time-left" class="form-label">Time Left</label>
                <input
                  id="time-left"
                  class="form-control"
                  type="text"
                  placeholder="1:23"
                  required
                />
              </div>
              <div class="col-sm-4">
                <button type="submit" class="btn btn-primary w-100">
                  Submit
                </button>
              </div>
            </form>
            <div id="submit-status" class="form-text mt-2"></div>
          </div>
        </div>
      </section>

      <!-- Bootstrap Tabs -->
      <ul
        class="nav nav-pills nav-fill gap-2 small bg-body-tertiary rounded-3 p-2"
        id="mainTabs"
        role="tablist"
      >
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            data-bs-toggle="tab"
            data-bs-target="#tab-today"
            type="button"
            role="tab"
          >
            Today‚Äôs Standings
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-points"
            type="button"
            role="tab"
          >
            Season Standings
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-fame"
            type="button"
            role="tab"
          >
            Hall of Champions
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-playoffs"
            type="button"
            role="tab"
          >
            Playoffs
          </button>
        </li>

        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="h2h-tab"
            data-bs-toggle="tab"
            data-bs-target="#tab-headtohead"
            type="button"
            role="tab"
          >
            Head to Head
          </button>
        </li>

        <!-- In your tabs UL -->
        <li class="nav-item" role="presentation" id="nav-admin-item">
          <button
            class="nav-link"
            id="admin-tab-btn"
            data-bs-toggle="tab"
            data-bs-target="#tab-admin"
            type="button"
            role="tab"
          >
            Admin
          </button>
        </li>
      </ul>

      <div class="tab-content py-3">
        <!-- Today‚Äôs Standings -->
        <div class="tab-pane fade show active" id="tab-today" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Today‚Äôs Standings</h2>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Score</th>
                      <th>%</th>
                      <th>Time Left</th>
                      <th id="standings-actions-th" style="width: 170px">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody id="standings-body"></tbody>
                </table>
              </div>
              <div id="empty-standings" class="note">No entries yet today.</div>
            </div>
          </section>
        </div>

        <!-- All-Time Points -->
        <div class="tab-pane fade" id="tab-points" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Season Standings</h2>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Points</th>
                    </tr>
                  </thead>
                  <tbody id="points-body"></tbody>
                </table>
              </div>
              <div id="empty-points" class="note">No points yet.</div>
            </div>
          </section>
        </div>

        <!-- Hall of Champions -->
        <div class="tab-pane fade" id="tab-fame" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">üèÜ Hall of Champions</h2>
              <p class="text-muted mb-4">
                Celebrating the greatest achievements in Sporcle League history.
              </p>

              <!-- Season selector -->
              <div class="mb-4">
                <select
                  id="season-selector"
                  class="form-select"
                  style="max-width: 200px"
                >
                  <option value="1" selected>Season 1</option>
                </select>
              </div>

              <!-- Awards Grid -->
              <div id="awards-container" class="row g-4">
                <!-- Awards will be rendered here by JS -->
              </div>

              <div id="empty-fame" class="note d-none">
                No champions yet for this season.
              </div>
            </div>
          </section>
        </div>

        <!-- Playoffs tab -->
        <div
          class="tab-pane fade"
          id="tab-playoffs"
          role="tabpanel"
          aria-labelledby="tab-playoffs-tab"
        >
          <!-- Join Playoff Match (only shown after Finalize Playoffs) -->
          <div id="playoff-join-card" class="card mb-3">
            <div class="card-body">
              <h5 class="card-title">Playoff Match</h5>
              <p class="card-text">
                Enter your alias to join your assigned playoff matchup.
              </p>

              <form id="playoff-join-form" class="row g-2">
                <div class="col-sm-4">
                  <label for="playoff-alias" class="form-label">Alias</label>
                  <input
                    type="text"
                    id="playoff-alias"
                    class="form-control"
                    placeholder="ellisjf"
                    required
                  />
                </div>

                <div class="col-sm-4 align-self-end">
                  <button type="submit" class="btn btn-primary">
                    Join Playoff Match
                  </button>
                </div>
              </form>

              <div id="playoff-join-status" class="form-text mt-2"></div>
            </div>
          </div>

          <!-- Bracket (always visible) -->
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Playoffs</h2>

              <div id="playoffs-bracket" class="playoff-bracket">
                <!-- Dynamic bracket will be rendered here -->
              </div>

              <div class="note mt-2">
                Bracket is seeded by Season Standings. Later rounds will be
                filled in as winners are decided.
              </div>
            </div>
          </section>
        </div>

        <!-- Head to Head -->
        <div class="tab-pane fade" id="tab-headtohead" role="tabpanel">
          <section class="card mt-3">
            <div class="card-body">
              <h2 class="h5 mb-3">Head to Head</h2>

              <!-- Category Queue Selection -->
              <div class="mb-4">
                <label class="form-label fw-bold">Select Queue Category</label>
                <div class="row g-2" id="h2h-category-grid">
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn active"
                      data-category="random"
                    >
                      üé≤ Random
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="geography"
                    >
                      üåç Geography
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="history"
                    >
                      üèõÔ∏è History
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="science"
                    >
                      üî¨ Science
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="sports"
                    >
                      ‚öΩ Sports
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="entertainment"
                    >
                      üé¨ Movies/TV
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="music"
                    >
                      üéµ Music
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="literature"
                    >
                      üìö Literature
                    </button>
                  </div>
                  <div class="col-6 col-md-3">
                    <button
                      type="button"
                      class="btn btn-outline-secondary w-100 h2h-category-btn"
                      data-category="misc"
                    >
                      ‚ùì Misc
                    </button>
                  </div>
                </div>
                <div class="form-text mt-2">
                  <strong>Random:</strong> Match with anyone in any queue.
                  <strong>Category:</strong> Match only with others in the same
                  category.
                </div>
              </div>

              <!-- Logged-in user matchmaking -->
              <div id="h2h-user-info" class="mb-3 d-none">
                <div class="d-flex align-items-center gap-3">
                  <div>
                    <span class="text-muted">Playing as:</span>
                    <strong id="h2h-user-display"></strong>
                    <span class="text-muted"
                      >(<span id="h2h-user-alias"></span>)</span
                    >
                  </div>
                  <button
                    type="button"
                    class="btn btn-primary"
                    id="h2h-find-btn"
                  >
                    Find Match
                  </button>
                </div>
              </div>

              <!-- Sign-in prompt for non-logged-in users -->
              <div id="h2h-signin-prompt" class="mb-3">
                <p class="text-muted mb-2">
                  Sign in to play Head to Head matches.
                </p>
                <button
                  type="button"
                  class="btn btn-outline-primary"
                  id="h2h-signin-btn"
                >
                  Sign In to Play
                </button>
              </div>

              <!-- Hidden field to store selected category -->
              <input type="hidden" id="h2h-selected-category" value="random" />

              <button
                id="h2h-cancel-btn"
                class="btn btn-outline-secondary btn-sm mb-3 d-none"
              >
                Cancel Matchmaking
              </button>

              <div id="h2h-status" class="mb-2 text-muted">
                Select a category, enter your name and alias, then click "Find
                Match" to join the queue.
              </div>

              <!-- Match info once paired -->
              <div id="h2h-match-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">You have been matched!</h3>
                  <p class="mb-1">
                    <strong>Category:</strong>
                    <span
                      id="h2h-match-category"
                      class="badge bg-secondary"
                    ></span>
                  </p>
                  <p class="mb-1">
                    <strong>You:</strong> <span id="h2h-you-name"></span> (<span
                      id="h2h-you-alias"
                    ></span
                    >)
                  </p>
                  <p class="mb-1">
                    <strong>Opponent:</strong>
                    <span id="h2h-opp-name"></span> (<span
                      id="h2h-opp-alias"
                    ></span
                    >)
                  </p>
                  <p class="mb-1">
                    <strong>Quiz:</strong>
                    <button
                      id="h2h-veto-btn"
                      class="btn btn-warning btn-sm ms-2 d-none"
                    >
                      Use Veto
                    </button>

                    <a href="#" target="_blank" id="h2h-quiz-link">Open quiz</a>
                  </p>
                </div>
              </div>

              <!-- Your score entry (only you edit yours) -->
              <div id="h2h-score-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">Submit Your Result</h3>
                  <form id="h2h-score-form" class="row g-2">
                    <div class="col-md-6">
                      <label for="h2h-score" class="form-label">
                        Your Score (num/den)
                      </label>
                      <input
                        type="text"
                        id="h2h-score"
                        class="form-control"
                        placeholder="10/15"
                        required
                      />
                    </div>
                    <div class="col-md-4">
                      <label for="h2h-time" class="form-label">
                        Time Left (mm:ss)
                      </label>
                      <input
                        type="text"
                        id="h2h-time"
                        class="form-control"
                        placeholder="01:23"
                        required
                      />
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                      <button
                        type="submit"
                        class="btn btn-success w-100"
                        id="h2h-score-submit-btn"
                      >
                        Submit
                      </button>
                    </div>
                  </form>
                  <div id="h2h-score-status" class="form-text mt-1"></div>
                </div>
              </div>

              <!-- Final results, shown only after both players submitted -->
              <div id="h2h-result-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">Match Result</h3>
                  <p class="mb-1" id="h2h-result-summary"></p>
                  <ul class="mb-0 small" id="h2h-result-detail"></ul>
                </div>
              </div>

              <!-- Standings section with category tabs -->
              <div class="mt-4">
                <h3 class="h6">Head-to-Head Standings</h3>

                <!-- Category tabs for standings -->
                <ul
                  class="nav nav-pills mb-3"
                  id="h2h-standings-tabs"
                  role="tablist"
                >
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link active"
                      id="h2h-tab-overall"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-overall"
                      type="button"
                      role="tab"
                    >
                      Overall
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-geography"
                      type="button"
                      role="tab"
                    >
                      üåç
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-history"
                      type="button"
                      role="tab"
                    >
                      üèõÔ∏è
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-science"
                      type="button"
                      role="tab"
                    >
                      üî¨
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-sports"
                      type="button"
                      role="tab"
                    >
                      ‚öΩ
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-entertainment"
                      type="button"
                      role="tab"
                    >
                      üé¨
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-music"
                      type="button"
                      role="tab"
                    >
                      üéµ
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-literature"
                      type="button"
                      role="tab"
                    >
                      üìö
                    </button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button
                      class="nav-link"
                      data-bs-toggle="pill"
                      data-bs-target="#h2h-standings-misc"
                      type="button"
                      role="tab"
                    >
                      ‚ùì
                    </button>
                  </li>
                </ul>

                <div class="tab-content" id="h2h-standings-content">
                  <!-- Overall standings -->
                  <div
                    class="tab-pane fade show active"
                    id="h2h-standings-overall"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Streak</th>
                            <th>Best Streak</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body">
                          <!-- filled by JS -->
                        </tbody>
                      </table>
                    </div>
                  </div>

                  <!-- Category-specific standings (generated dynamically) -->
                  <div
                    class="tab-pane fade"
                    id="h2h-standings-geography"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-geography"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-geography">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-history"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-history"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-history">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-science"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-science"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-science">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-sports"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-sports"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-sports">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-entertainment"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-entertainment"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-entertainment">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-music"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-music"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-music">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-literature"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-literature"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-literature">
                      No matches yet in this category.
                    </div>
                  </div>

                  <div
                    class="tab-pane fade"
                    id="h2h-standings-misc"
                    role="tabpanel"
                  >
                    <div class="table-responsive">
                      <table class="table table-sm align-middle">
                        <thead>
                          <tr>
                            <th>#</th>
                            <th>Display Name</th>
                            <th>Alias</th>
                            <th>W</th>
                            <th>L</th>
                            <th>Win%</th>
                          </tr>
                        </thead>
                        <tbody id="h2h-standings-body-misc"></tbody>
                      </table>
                    </div>
                    <div class="text-muted small" id="h2h-empty-misc">
                      No matches yet in this category.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <!-- Admin -->
        <div class="tab-pane fade" id="tab-admin" role="tabpanel">
          <section class="card" id="admin-panel">
            <div class="card-body">
              <h2 class="h5 mb-3">Admin</h2>

              <!-- Auth controls (Google sign in restored) -->
              <div class="d-flex flex-wrap gap-2 mb-2">
                <button id="admin-signin" class="btn btn-secondary">
                  Admin: Sign in with Google
                </button>
                <button
                  id="grant-admin"
                  class="btn btn-outline-secondary d-none"
                >
                  Grant Admin to me
                </button>
                <button id="admin-signout" class="btn btn-warning d-none">
                  Sign out (admin)
                </button>
              </div>

              <!-- Day controls -->
              <div class="d-flex flex-wrap gap-2 mb-3">
                <button id="finish-day" class="btn btn-primary">
                  Finish Day (award points)
                </button>
                <button id="reset-scores" class="btn btn-danger">
                  Reset Scores
                </button>
              </div>

              <!-- Delete from leaderboard -->
              <h3 class="h6 mt-2 mb-2">Delete From Leaderboard</h3>
              <form id="delete-points-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="delete-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or existing doc ID"
                  required
                />
                <button type="submit" class="btn btn-danger">Delete</button>
              </form>

              <!-- Edit points -->
              <h3 class="h6 mt-2 mb-2">Edit Points</h3>
              <form id="points-edit-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="pe-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or doc ID"
                  required
                />
                <select id="pe-mode" class="form-select">
                  <option value="set">Set to value</option>
                  <option value="inc">Increment by</option>
                </select>
                <input
                  id="pe-value"
                  class="form-control"
                  type="number"
                  placeholder="Points"
                  required
                />
                <input
                  id="pe-dn"
                  class="form-control"
                  type="text"
                  placeholder="Display name (optional)"
                />
                <button type="submit" class="btn btn-primary">Apply</button>
              </form>

              <!-- Retro finishes -->
              <h3 class="h6 mt-2 mb-2">Retroactively Set Firsts/Lasts</h3>
              <form id="finishes-edit-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="fe-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or doc ID"
                  required
                />
                <select id="fe-mode" class="form-select">
                  <option value="set">Set</option>
                  <option value="inc">Increment</option>
                </select>
                <input
                  id="fe-firsts"
                  class="form-control"
                  type="number"
                  placeholder="Firsts"
                />
                <input
                  id="fe-lasts"
                  class="form-control"
                  type="number"
                  placeholder="Lasts"
                />
                <button type="submit" class="btn btn-primary">Apply</button>
              </form>

              <!-- Playoff Controls -->
              <div class="card mb-3">
                <div class="card-body">
                  <h5 class="card-title">Playoffs Control</h5>
                  <p class="card-text">
                    Use this to finalize the playoffs bracket and enable playoff
                    features for everyone.
                  </p>
                  <button
                    id="playoffs-finalize-btn"
                    class="btn btn-danger btn-sm"
                  >
                    Finalize Playoffs
                  </button>
                  <button
                    id="playoffs-unfinalize-btn"
                    class="btn btn-outline-secondary btn-sm ms-2 d-none"
                  >
                    Reopen Playoffs (Admin only)
                  </button>
                  <button id="add-seeds-btn" class="btn btn-info btn-sm ms-2">
                    Add Seeds to Bracket
                  </button>
                  <button
                    id="reset-bracket-btn"
                    class="btn btn-outline-danger btn-sm ms-2"
                  >
                    üîÑ Reset & Initialize Bracket
                  </button>
                  <div
                    id="playoffs-finalize-status"
                    class="form-text mt-2"
                  ></div>
                </div>
              </div>

              <!-- Season Management -->
              <div class="card mb-3">
                <div class="card-body">
                  <h5 class="card-title">Season Management</h5>
                  <p class="card-text text-muted">
                    Use these controls to end the current season and start
                    fresh.
                  </p>

                  <div class="mb-3">
                    <label for="season-number-input" class="form-label"
                      >Current Season Number</label
                    >
                    <input
                      type="number"
                      id="season-number-input"
                      class="form-control"
                      style="max-width: 100px"
                      value="1"
                      min="1"
                    />
                  </div>

                  <div class="d-flex flex-wrap gap-2 mb-2">
                    <button id="end-playoffs-btn" class="btn btn-warning">
                      üèÅ End Playoffs
                    </button>
                    <button id="archive-season-btn" class="btn btn-danger">
                      üì¶ Archive & Reset Season
                    </button>
                  </div>

                  <div class="form-text mb-2">
                    <strong>End Playoffs:</strong> Closes playoffs and shows
                    projected bracket based on current standings.<br />
                    <strong>Archive & Reset:</strong> Saves current points and
                    H2H records to archive, then clears them for a new season.
                  </div>

                  <div
                    id="season-management-status"
                    class="form-text mt-2"
                  ></div>
                </div>
              </div>

              <!-- Manual Playoff Result Entry -->
              <div class="card mb-3">
                <div class="card-body">
                  <h5 class="card-title">Manual Playoff Result Entry</h5>
                  <p class="card-text">
                    Manually set the winner for a playoff matchup. This is
                    useful for entering results of matches that were played
                    offline.
                  </p>

                  <form id="manual-playoff-result-form" class="row g-2">
                    <div class="col-md-3">
                      <label for="playoff-round" class="form-label"
                        >Round</label
                      >
                      <input
                        type="number"
                        id="playoff-round"
                        class="form-control"
                        placeholder="1"
                        min="1"
                        required
                      />
                    </div>

                    <div class="col-md-3">
                      <label for="playoff-match-index" class="form-label"
                        >Match Index</label
                      >
                      <input
                        type="number"
                        id="playoff-match-index"
                        class="form-control"
                        placeholder="0"
                        min="0"
                        required
                      />
                    </div>

                    <div class="col-md-4">
                      <label for="playoff-winner-alias" class="form-label"
                        >Winner Alias</label
                      >
                      <input
                        type="text"
                        id="playoff-winner-alias"
                        class="form-control"
                        placeholder="jdoe"
                        required
                      />
                    </div>

                    <div class="col-md-2 d-flex align-items-end">
                      <button type="submit" class="btn btn-warning w-100">
                        Set Winner
                      </button>
                    </div>
                  </form>

                  <div id="manual-playoff-status" class="form-text mt-2"></div>

                  <hr class="my-3" />

                  <h6>Quick Match Lookup</h6>
                  <div class="table-responsive mt-2">
                    <table
                      class="table table-sm table-bordered"
                      id="playoff-matches-table"
                    >
                      <thead>
                        <tr>
                          <th>Round</th>
                          <th>Match #</th>
                          <th>Player 1</th>
                          <th>Player 2</th>
                          <th>Status</th>
                          <th>Winner</th>
                          <th>Action</th>
                        </tr>
                      </thead>
                      <tbody id="playoff-matches-body">
                        <!-- Filled by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <!-- Alias migration -->
              <h3 class="h6 mt-2 mb-2">Alias Migration</h3>
              <form id="alias-migrate-form" class="d-flex flex-wrap gap-2">
                <input
                  id="old-id"
                  class="form-control"
                  type="text"
                  placeholder="Old points doc id (e.g., old name)"
                  required
                />
                <input
                  id="new-alias"
                  class="form-control"
                  type="text"
                  placeholder="New alias (e.g., jdoe42)"
                  required
                />
                <input
                  id="new-dn"
                  class="form-control"
                  type="text"
                  placeholder="Display name (optional)"
                />
                <button type="submit" class="btn btn-primary">
                  Move/Merge
                </button>
              </form>
            </div>
          </section>
        </div>
      </div>
    </main>

    <!-- Firebase + module: exposes helpers used by app.js -->
    <script type="module">
      // Firebase SDK imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInAnonymously,
        GoogleAuthProvider,
        signInWithPopup,
        signOut,
        getIdTokenResult,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
      import {
        getFirestore,
        collection,
        doc,
        addDoc,
        getDocs,
        getDoc,
        query,
        where,
        orderBy,
        limit,
        serverTimestamp,
        writeBatch,
        setDoc,
        runTransaction,
        deleteDoc,
        updateDoc,
        Timestamp,
        onSnapshot,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import {
        getFunctions,
        httpsCallable,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-functions.js";

      // Replace with your real config from Firebase console
      const firebaseConfig = {
        apiKey: "AIzaSyCljmg5V4r0q7vZ5X6K5Wn78iTT7PtKIqU",
        authDomain: "sporcle-league-ced80.firebaseapp.com",
        projectId: "sporcle-league-ced80",
        storageBucket: "sporcle-league-ced80.firebasestorage.app",
        messagingSenderId: "34922576123",
        appId: "1:34922576123:web:429c7e4568455c6d4d185e",
        measurementId: "G-8V028YY2NK",
      };

      // 2) Init Firebase
      const app = initializeApp(firebaseConfig);
      console.log("firebaseConfig.projectId =", firebaseConfig.projectId);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const functions = getFunctions(app);
      const provider = new GoogleAuthProvider();

      // 3) Theme toggle (affects entire page via Bootstrap color modes)
      (function themeInit() {
        var key = "bsTheme";
        var btn = document.getElementById("theme-toggle");
        var root = document.documentElement;
        function apply(t) {
          root.setAttribute("data-bs-theme", t);
          if (btn) btn.textContent = t === "dark" ? "üåô" : "üåû";
          try {
            localStorage.setItem(key, t);
          } catch (e) {}
        }
        var saved = null;
        try {
          saved = localStorage.getItem(key);
        } catch (e) {}
        apply(saved === "light" ? "light" : "dark");
        if (btn)
          btn.addEventListener("click", function () {
            var next =
              root.getAttribute("data-bs-theme") === "dark" ? "light" : "dark";
            apply(next);
          });
      })();

      // 4) Firestore refs
      const todayCol = collection(db, "today");
      console.log("todayCol path =", todayCol.path);
      const pointsCol = collection(db, "points");
      const quizDoc = doc(db, "quizLink", "today");
      const wheelSpinDoc = doc(db, "wheelSpin", "today");
      const wheelQuizzesCol = collection(db, "wheelQuizzes");

      // 5) Expose app helpers used by app.js
      window.shared = {
        // Today submissions (alias is the doc id)
        submitScore: async function ({
          alias,
          displayName,
          num,
          den,
          ratio,
          timeLeft,
        }) {
          var id = String(alias || "")
            .trim()
            .toLowerCase();
          if (!id) throw new Error("Alias required");
          await setDoc(
            doc(todayCol, id),
            {
              alias: id,
              displayName: displayName,
              num: num,
              den: den,
              ratio: ratio,
              timeLeft: timeLeft || 0,
              t: Date.now(),
            },
            { merge: true }
          );
        },
        deleteEntry: async function (alias) {
          var id = String(alias || "")
            .trim()
            .toLowerCase();
          await deleteDoc(doc(todayCol, id));
        },
        upsertEntry: async function ({
          oldAlias,
          newAlias,
          displayName,
          num,
          den,
        }) {
          var src = String(oldAlias || "")
            .trim()
            .toLowerCase();
          var dst = String(newAlias || oldAlias || "")
            .trim()
            .toLowerCase();
          var ratio = num / den;
          await setDoc(
            doc(todayCol, dst),
            {
              alias: dst,
              displayName: displayName,
              num: num,
              den: den,
              ratio: ratio,
              t: Date.now(),
            },
            { merge: true }
          );
          if (dst !== src) await deleteDoc(doc(todayCol, src));
        },

        // Live listeners
        listenToday: function (cb) {
          return onSnapshot(todayCol, cb, function (err) {
            console.error("[today] err:", err);
          });
        },
        listenPoints: function (cb) {
          return onSnapshot(pointsCol, cb, function (err) {
            console.error("[points] err:", err);
          });
        },

        // Quiz link
        setQuizLink: async function (url) {
          await setDoc(
            quizDoc,
            { url: url, updated: Date.now() },
            { merge: true }
          );
        },
        listenQuizLink: function (cb) {
          return onSnapshot(quizDoc, cb);
        },

        // Wheel spin
        setWheelSpin: async function (spinData) {
          await setDoc(
            wheelSpinDoc,
            { ...spinData, timestamp: Date.now() },
            { merge: false }
          );
        },
        listenWheelSpin: function (cb) {
          return onSnapshot(wheelSpinDoc, cb);
        },

        // Wheel quizzes collection
        listenWheelQuizzes: function (cb) {
          return onSnapshot(wheelQuizzesCol, cb, function (err) {
            console.error("[wheelQuizzes] err:", err);
          });
        },

        // Callables (admin)
        finishDay: httpsCallable(functions, "finishDayAwardPoints"),
        resetScores: httpsCallable(functions, "resetAllPoints"),
        makeAdmin: httpsCallable(functions, "makeMeAdmin"),
        adminMovePoints: httpsCallable(functions, "adminMovePoints"),
        adminSetAliasFields: httpsCallable(functions, "adminSetAliasFields"),
        adminDeletePoints: httpsCallable(functions, "adminDeletePointsDoc"),
        adminUpdatePoints: httpsCallable(functions, "adminUpdatePoints"),
        adminUpdateFinishes: httpsCallable(functions, "adminUpdateFinishes"),

        // User profiles
        getUserProfile: async function (uid) {
          const docSnap = await getDoc(doc(db, "userProfiles", uid));
          return docSnap.exists() ? docSnap.data() : null;
        },
        setUserProfile: async function (uid, data) {
          await setDoc(
            doc(db, "userProfiles", uid),
            {
              ...data,
              updatedAt: Date.now(),
            },
            { merge: true }
          );
        },
        checkAliasAvailable: async function (alias, excludeUid) {
          const q = query(
            collection(db, "userProfiles"),
            where("alias", "==", alias.toLowerCase())
          );
          const snap = await getDocs(q);
          if (snap.empty) return true;
          // If only match is current user, it's available
          return snap.docs.length === 1 && snap.docs[0].id === excludeUid;
        },
      };

      // 6) Auth helpers for app.js and buttons
      window.authHelpers = {
        signInAsAdmin: async function () {
          await signInWithPopup(auth, provider);
          if (auth.currentUser) {
            await auth.currentUser.getIdToken(true);
          }
        },
        signOut: function () {
          return signOut(auth);
        },
        onChange: function (cb) {
          return onAuthStateChanged(auth, cb);
        },
        getIdTokenResult: function () {
          return getIdTokenResult(auth.currentUser);
        },
        // Email/password auth
        signInWithEmail: function (email, password) {
          return signInWithEmailAndPassword(auth, email, password);
        },
        createAccount: function (email, password) {
          return createUserWithEmailAndPassword(auth, email, password);
        },
        getCurrentUser: function () {
          return auth.currentUser;
        },
      };

      // 7) Admin UI control: header sign in, hide Admin tab when not admin
      var navAdminItem = document.getElementById("nav-admin-item"); // <li> wrapper of Admin tab
      var adminTabBtn = document.getElementById("admin-tab-btn"); // <button> Admin tab
      var adminSigninHeader = document.getElementById("admin-signin-header"); // header "Admin sign in" button
      var globalOutBtn = document.getElementById("account-signout"); // global sign out button

      function toggleAdminUI(isAdmin) {
        // Show or hide Admin tab
        if (navAdminItem) navAdminItem.classList.toggle("d-none", !isAdmin);

        // If user is not admin but Admin tab is active, switch to first visible tab
        if (
          !isAdmin &&
          adminTabBtn &&
          adminTabBtn.classList.contains("active")
        ) {
          var firstTabBtn = document.querySelector(
            "#mainTabs .nav-link:not(.d-none)"
          );
          if (firstTabBtn && window.bootstrap && window.bootstrap.Tab) {
            new window.bootstrap.Tab(firstTabBtn).show();
          }
        }

        // Header admin sign in only when not admin
        if (adminSigninHeader)
          adminSigninHeader.classList.toggle("d-none", !!isAdmin);

        // Let app.js reveal per-element admin controls
        try {
          if (typeof window.refreshAdminUI === "function")
            window.refreshAdminUI(isAdmin);
        } catch (e) {}
      }

      async function signInWithGoogle() {
        await signInWithPopup(auth, provider);
        if (auth.currentUser) await auth.currentUser.getIdToken(true);
      }

      if (adminSigninHeader) {
        adminSigninHeader.addEventListener("click", function () {
          signInWithGoogle().catch(function (e) {
            console.error(e);
          });
        });
      }

      if (globalOutBtn) {
        globalOutBtn.addEventListener("click", function () {
          signOut(auth)
            .then(function () {
              location.reload();
            })
            .catch(function (e) {
              console.error(e);
            });
        });
      }

      // 8) Auth state and claims watcher
      onAuthStateChanged(auth, async (u) => {
        if (!u) {
          // Allow anonymous users (so they can submit scores)
          try {
            await signInAnonymously(auth);
          } catch (e) {}
          toggleAdminUI(false);
          if (globalOutBtn) globalOutBtn.classList.add("d-none");
          return;
        }

        try {
          // Check custom claims
          const token = await getIdTokenResult(u, true);
          const isAdmin = !!(
            token &&
            token.claims &&
            token.claims.admin === true
          );
          window.__isAdmin = isAdmin;

          // Only show the Sign Out button for admins
          if (globalOutBtn) globalOutBtn.classList.toggle("d-none", !isAdmin);

          toggleAdminUI(isAdmin);
        } catch (e) {
          console.error("claims error", e);
          window.__isAdmin = false;
          if (globalOutBtn) globalOutBtn.classList.add("d-none");
          toggleAdminUI(false);
        }
      });

      // Head-to-Head DOM elements (add to your existing references)
      const h2hUserInfo = document.getElementById("h2h-user-info");
      const h2hUserDisplay = document.getElementById("h2h-user-display");
      const h2hUserAlias = document.getElementById("h2h-user-alias");
      const h2hSigninPrompt = document.getElementById("h2h-signin-prompt");
      const h2hSigninBtn = document.getElementById("h2h-signin-btn");
      const h2hFindBtn = document.getElementById("h2h-find-btn");
      const h2hStatus = document.getElementById("h2h-status");
      const h2hMatchCard = document.getElementById("h2h-match-card");
      const h2hYouName = document.getElementById("h2h-you-name");
      const h2hYouAlias = document.getElementById("h2h-you-alias");
      const h2hOppName = document.getElementById("h2h-opp-name");
      const h2hOppAlias = document.getElementById("h2h-opp-alias");
      const h2hQuizLink = document.getElementById("h2h-quiz-link");
      const h2hMatchCategory = document.getElementById("h2h-match-category");

      const h2hScoreCard = document.getElementById("h2h-score-card");
      const h2hScoreForm = document.getElementById("h2h-score-form");
      const h2hScoreInput = document.getElementById("h2h-score");
      const h2hTimeInput = document.getElementById("h2h-time");
      const h2hScoreStatus = document.getElementById("h2h-score-status");

      const h2hResultCard = document.getElementById("h2h-result-card");
      const h2hResultSummary = document.getElementById("h2h-result-summary");
      const h2hResultDetail = document.getElementById("h2h-result-detail");

      const h2hStandingsBody = document.getElementById("h2h-standings-body");
      const h2hSelectedCategoryInput = document.getElementById(
        "h2h-selected-category"
      );

      // H2H Category definitions
      const h2hCategories = {
        random: { name: "Random", icon: "üé≤" },
        geography: { name: "Geography", icon: "üåç" },
        history: { name: "History", icon: "üèõÔ∏è" },
        science: { name: "Science", icon: "üî¨" },
        sports: { name: "Sports", icon: "‚öΩ" },
        entertainment: { name: "Movies/TV", icon: "üé¨" },
        music: { name: "Music", icon: "üéµ" },
        literature: { name: "Literature", icon: "üìö" },
        misc: { name: "Misc", icon: "‚ùì" },
      };

      // Category button selection handlers
      const h2hCategoryBtns = document.querySelectorAll(".h2h-category-btn");
      h2hCategoryBtns.forEach((btn) => {
        btn.addEventListener("click", function () {
          // Remove active from all buttons
          h2hCategoryBtns.forEach((b) => b.classList.remove("active"));
          // Add active to clicked button
          this.classList.add("active");
          // Update hidden input
          const category = this.dataset.category;
          if (h2hSelectedCategoryInput) {
            h2hSelectedCategoryInput.value = category;
          }
        });
      });

      let h2hQueueUnsub = null;
      let h2hQueueDocRef = null;
      let h2hCurrentMatchRef = null;
      let h2hCurrentSide = null; // "playerA" or "playerB"
      let h2hYouData = null; // {displayName, alias, clientId}
      let h2hSelectedCategory = "random"; // Track selected category
      let h2hRecentQuizUrls = []; // Track recent quiz URLs to avoid repeats

      let h2hQueueStartTime = null;
      let h2hQueueIntervalId = null;
      let h2hQueueTimeoutId = null;

      let h2hMatchShownOnce = false;

      const H2H_QUEUE_TIMEOUT_SECONDS = 10 * 60; // 10 minutes

      const h2hCancelBtn = document.getElementById("h2h-cancel-btn");
      let h2hMatchRetryId = null;

      function clearHeadToHeadQueueTimers() {
        h2hQueueStartTime = null;
        if (h2hQueueIntervalId) {
          clearInterval(h2hQueueIntervalId);
          h2hQueueIntervalId = null;
        }
        if (h2hQueueTimeoutId) {
          clearTimeout(h2hQueueTimeoutId);
          h2hQueueTimeoutId = null;
        }
        if (h2hMatchRetryId) {
          clearInterval(h2hMatchRetryId);
          h2hMatchRetryId = null;
        }
      }

      function startHeadToHeadQueueTimers(db, myQueueRef, youData) {
        clearHeadToHeadQueueTimers();
        h2hQueueStartTime = Date.now();

        // live "in queue" indicator
        h2hQueueIntervalId = setInterval(() => {
          if (!h2hQueueStartTime) return;
          const elapsedSec = Math.floor(
            (Date.now() - h2hQueueStartTime) / 1000
          );
          const pretty = formatSecondsAsMMSS(elapsedSec);
          const categoryInfo =
            h2hCategories[h2hSelectedCategory] || h2hCategories.random;
          setH2HStatus(
            categoryInfo.icon +
              " Waiting for an opponent... In queue for " +
              pretty
          );
        }, 1000);

        // Periodically retry matchmaking every 3 seconds
        h2hMatchRetryId = setInterval(async () => {
          if (!myQueueRef || !youData) return;

          // Check if we're still waiting
          try {
            const snap = await getDoc(myQueueRef);
            if (!snap.exists() || snap.data().status !== "waiting") {
              // We've been matched or removed, stop retrying
              clearInterval(h2hMatchRetryId);
              h2hMatchRetryId = null;
              return;
            }

            // Try to find a match
            await tryHeadToHeadMatchmaking(db, myQueueRef, youData);
          } catch (e) {
            console.error("Error in matchmaking retry:", e);
          }
        }, 3000);

        // hard timeout at 10 minutes
        h2hQueueTimeoutId = setTimeout(() => {
          // if we're still waiting after 10 minutes, auto-cancel
          cancelHeadToHeadQueue(
            "Matchmaking timed out after " +
              formatSecondsAsMMSS(H2H_QUEUE_TIMEOUT_SECONDS) +
              ". Please try again."
          );
        }, H2H_QUEUE_TIMEOUT_SECONDS * 1000);
      }

      async function cancelHeadToHeadQueue(message) {
        clearHeadToHeadQueueTimers();

        if (h2hQueueUnsub) {
          h2hQueueUnsub();
          h2hQueueUnsub = null;
        }

        if (h2hQueueDocRef) {
          try {
            await deleteDoc(h2hQueueDocRef);
          } catch (err) {
            console.error("Error deleting queue doc on cancel", err);
          }
          h2hQueueDocRef = null;
        }

        h2hCurrentMatchRef = null;
        h2hCurrentSide = null;
        h2hYouData = null;

        if (h2hMatchCard) h2hMatchCard.classList.add("d-none");
        if (h2hScoreCard) h2hScoreCard.classList.add("d-none");
        if (h2hResultCard) h2hResultCard.classList.add("d-none");

        if (h2hScoreInput) {
          h2hScoreInput.disabled = false;
          h2hScoreInput.value = "";
        }
        if (h2hTimeInput) {
          h2hTimeInput.disabled = false;
          h2hTimeInput.value = "";
        }
        const submitBtn = document.getElementById("h2h-score-submit-btn");
        if (submitBtn) submitBtn.disabled = false;

        if (h2hCancelBtn) h2hCancelBtn.classList.add("d-none");
        if (h2hFindBtn) h2hFindBtn.disabled = false;

        setH2HStatus(message || "Matchmaking cancelled.");
      }

      if (h2hCancelBtn) {
        h2hCancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          cancelHeadToHeadQueue();
        });
      }

      async function cleanupOldQueueEntries(db, clientId) {
        const queueRef = collection(db, "headtoheadQueue");
        const q = query(
          queueRef,
          where("clientId", "==", clientId),
          where("status", "==", "waiting")
        );
        const snap = await getDocs(q);
        if (snap.empty) return;

        const batch = writeBatch(db);
        snap.forEach((docSnap) => {
          batch.delete(docSnap.ref);
        });
        await batch.commit();
      }

      // ---- Head-to-Head: persistent client id per browser ----
      function getOrCreateHeadToHeadClientId() {
        const key = "h2hClientId";
        const existing = window.localStorage.getItem(key);
        if (existing) return existing;

        const newId =
          "h2h_" +
          Math.random().toString(36).slice(2) +
          Date.now().toString(36);

        window.localStorage.setItem(key, newId);
        return newId;
      }

      function parseScoreString(raw) {
        const s = (raw || "").trim();
        const parts = s.split("/");
        if (parts.length !== 2) return null;
        const correct = parseInt(parts[0], 10);
        const total = parseInt(parts[1], 10);
        if (
          !Number.isFinite(correct) ||
          !Number.isFinite(total) ||
          total <= 0 ||
          correct < 0 ||
          correct > total
        ) {
          return null;
        }
        return {
          rawScore: s,
          correct,
          total,
          pct: correct / total,
        };
      }

      function parseTimeString(raw) {
        const s = (raw || "").trim();
        if (!s) return null;

        // allow "mm:ss" or just "ss"
        const parts = s.split(":");

        let seconds;
        if (parts.length === 1) {
          const sec = Number(parts[0]);
          if (!Number.isFinite(sec) || sec < 0) return null;
          seconds = Math.floor(sec);
        } else if (parts.length === 2) {
          const min = Number(parts[0]);
          const sec = Number(parts[1]);
          if (
            !Number.isFinite(min) ||
            !Number.isFinite(sec) ||
            min < 0 ||
            sec < 0 ||
            sec >= 60
          ) {
            return null;
          }
          seconds = Math.floor(min * 60 + sec);
        } else {
          return null;
        }

        return seconds;
      }

      function formatSecondsAsMMSS(totalSeconds) {
        const s = Math.max(0, Math.floor(totalSeconds || 0));
        const m = Math.floor(s / 60);
        const sec = s % 60;
        const mm = String(m).padStart(2, "0");
        const ss = String(sec).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      function setH2HStatus(msg) {
        if (h2hStatus) h2hStatus.textContent = msg;
      }

      function showH2HMatch(matchData, you, opp, yourSideKey) {
        if (!matchData) return;

        // Show category badge
        const category = matchData.category || "random";
        const categoryInfo = h2hCategories[category] || h2hCategories.random;
        if (h2hMatchCategory) {
          h2hMatchCategory.textContent = `${categoryInfo.icon} ${categoryInfo.name}`;
        }

        h2hYouName.textContent = you.displayName;
        h2hYouAlias.textContent = you.alias;
        h2hOppName.textContent = opp.displayName;
        h2hOppAlias.textContent = opp.alias;
        h2hQuizLink.href = matchData.quizUrl;
        h2hQuizLink.textContent = matchData.quizUrl;

        h2hMatchCard.classList.remove("d-none");

        // score entry
        h2hScoreCard.classList.remove("d-none");
        h2hResultCard.classList.add("d-none");
        h2hScoreStatus.textContent =
          "Play the quiz, then submit your score and time.";

        h2hScoreInput.value = "";
        h2hTimeInput.value = "";

        // IMPORTANT: re-enable after previous match
        h2hScoreInput.disabled = false;
        h2hTimeInput.disabled = false;
        const submitBtn = document.getElementById("h2h-score-submit-btn");
        if (submitBtn) submitBtn.disabled = false;

        h2hCurrentSide = yourSideKey; // "playerA" or "playerB"
      }

      // ============================================================================
      // PLAYOFF SYSTEM - REWRITTEN
      // ============================================================================

      let __playoffsFinalized = false;
      let __playoffsEnded = false;
      let playoffCurrentMatchUnsub = null;
      let playoffMyMatchData = null; // stores {seriesId, matchDoc, myAlias, mySide}

      const playoffsConfigRef = doc(db, "config", "playoffs");
      const playoffsFinalizeBtn = document.getElementById(
        "playoffs-finalize-btn"
      );
      const playoffsUnfinalizeBtn = document.getElementById(
        "playoffs-unfinalize-btn"
      );
      const playoffsFinalizeStatus = document.getElementById(
        "playoffs-finalize-status"
      );
      const playoffJoinCard = document.getElementById("playoff-join-card");
      const playoffJoinForm = document.getElementById("playoff-join-form");
      const playoffAliasInput = document.getElementById("playoff-alias");
      const playoffJoinStatus = document.getElementById("playoff-join-status");
      const h2hVetoBtn = document.getElementById("h2h-veto-btn");

      // Listen to playoffs config to show/hide join form
      onSnapshot(
        playoffsConfigRef,
        (snap) => {
          const data = snap.exists() ? snap.data() : {};
          __playoffsFinalized = !!data.finalized;
          __playoffsEnded = !!data.ended;
          updatePlayoffsUIFromFlag();
        },
        (err) => {
          console.error("Error listening to playoffs config", err);
        }
      );

      function updatePlayoffsUIFromFlag() {
        if (playoffJoinCard) {
          // Hide join card if playoffs ended or not finalized
          playoffJoinCard.classList.toggle(
            "d-none",
            !__playoffsFinalized || __playoffsEnded
          );
        }

        // If playoffs ended, show projected bracket
        if (__playoffsEnded) {
          showProjectedBracket();
        }
      }

      // Show a projected bracket based on current standings (when playoffs ended)
      async function showProjectedBracket() {
        if (!playoffsBracketContainer) return;

        try {
          // Fetch current standings
          const pointsRef = collection(db, "points");
          const pointsSnap = await getDocs(
            query(pointsRef, orderBy("points", "desc"))
          );

          if (pointsSnap.empty) {
            playoffsBracketContainer.innerHTML = `
              <div class="alert alert-info">
                <h5>üèÜ Season Complete</h5>
                <p>Playoffs have ended. No standings data available for projected bracket.</p>
              </div>
            `;
            return;
          }

          // Build projected seeds
          const seeds = [];
          let seedNum = 1;
          pointsSnap.forEach((docSnap) => {
            const data = docSnap.data();
            seeds.push({
              seed: seedNum,
              alias: docSnap.id,
              displayName: data.displayName || docSnap.id,
              points: data.points || 0,
            });
            seedNum++;
          });

          // Pad to 32 if needed
          while (seeds.length < 32) {
            seeds.push({
              seed: seeds.length + 1,
              alias: "BYE",
              displayName: "BYE",
              points: 0,
              isBye: true,
            });
          }

          // Standard bracket pairings
          const bracketPairs = [
            [1, 32],
            [16, 17],
            [8, 25],
            [9, 24],
            [4, 29],
            [13, 20],
            [5, 28],
            [12, 21],
            [2, 31],
            [15, 18],
            [7, 26],
            [10, 23],
            [3, 30],
            [14, 19],
            [6, 27],
            [11, 22],
          ];

          const seedMap = {};
          seeds.forEach((s) => {
            seedMap[s.seed] = s;
          });

          // Build projected series for rendering
          const projectedSeries = bracketPairs.map((pair, idx) => {
            const [seed1, seed2] = pair;
            const p1 = seedMap[seed1];
            const p2 = seedMap[seed2];
            return {
              id: "projected-" + idx,
              round: 1,
              matchIndex: idx,
              aliases: [p1.alias, p2.alias],
              seeds: [seed1, seed2],
              displayNames: [p1.displayName, p2.displayName],
              status: "projected",
              winnerAlias: null,
            };
          });

          // Show header message
          const headerHtml = `
            <div class="alert alert-success mb-3">
              <h5>üèÜ Playoffs Complete - Projected Bracket</h5>
              <p class="mb-0">This shows the projected Round of 32 matchups based on current Season Standings.</p>
            </div>
          `;

          // Render the projected bracket
          await renderBracket(projectedSeries, true);

          // Prepend the header
          playoffsBracketContainer.insertAdjacentHTML("afterbegin", headerHtml);
        } catch (err) {
          console.error("Error showing projected bracket:", err);
          playoffsBracketContainer.innerHTML = `
            <div class="alert alert-warning">
              <h5>üèÜ Season Complete</h5>
              <p>Error loading projected bracket: ${err.message}</p>
            </div>
          `;
        }
      }

      // Admin: Finalize playoffs
      if (playoffsFinalizeBtn) {
        playoffsFinalizeBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          try {
            await setDoc(
              playoffsConfigRef,
              { finalized: true, finalizedAt: serverTimestamp() },
              { merge: true }
            );
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Playoffs finalized!";
            }
          } catch (err) {
            console.error("Error finalizing playoffs", err);
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Error finalizing playoffs.";
            }
          }
        });
      }

      // Admin: Unfinalize playoffs
      if (playoffsUnfinalizeBtn) {
        playoffsUnfinalizeBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (!confirm("Reopen playoffs for editing?")) return;
          try {
            await setDoc(
              playoffsConfigRef,
              { finalized: false },
              { merge: true }
            );
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Playoffs reopened.";
            }
          } catch (err) {
            console.error("Error unfinalizing playoffs", err);
          }
        });
      }

      // Player: Join playoff match
      if (playoffJoinForm) {
        playoffJoinForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          if (!__playoffsFinalized) {
            playoffJoinStatus.textContent = "Playoffs are not finalized yet.";
            return;
          }

          const rawAlias = playoffAliasInput.value.trim();
          if (!rawAlias) {
            playoffJoinStatus.textContent = "Please enter your alias.";
            return;
          }
          const alias = rawAlias.toLowerCase();

          try {
            playoffJoinStatus.textContent = "Finding your playoff matchup...";

            // Find the player's current playoff series
            const seriesDoc = await findActivePlayoffSeriesForAlias(db, alias);
            if (!seriesDoc) {
              playoffJoinStatus.textContent =
                "No active playoff matchup found for that alias.";
              return;
            }

            const series = seriesDoc.data();
            const clientId = getOrCreateHeadToHeadClientId();

            // Determine player info
            const aliases = series.aliases || [];
            if (!aliases.includes(alias)) {
              playoffJoinStatus.textContent =
                "Alias not found in this matchup.";
              return;
            }

            const oppAlias = aliases.find((a) => a !== alias);
            if (!oppAlias) {
              playoffJoinStatus.textContent = "Could not determine opponent.";
              return;
            }

            // Get display names from points collection
            const myPointsDoc = await getDoc(
              doc(collection(db, "points"), alias)
            );
            const oppPointsDoc = await getDoc(
              doc(collection(db, "points"), oppAlias)
            );

            const myDisplayName = myPointsDoc.exists()
              ? myPointsDoc.data().displayName || alias
              : alias;
            const oppDisplayName = oppPointsDoc.exists()
              ? oppPointsDoc.data().displayName || oppAlias
              : oppAlias;

            playoffJoinStatus.textContent = `Joining match vs ${oppDisplayName}...`;

            // Join the queue and start match
            await joinPlayoffMatchQueue(
              db,
              seriesDoc,
              alias,
              myDisplayName,
              oppAlias,
              oppDisplayName,
              clientId
            );
          } catch (err) {
            console.error("Error joining playoff match", err);
            playoffJoinStatus.textContent =
              "Error joining playoff match. See console.";
          }
        });
      }

      /**
       * Find the active playoff series for a given alias
       * Returns the series document with lowest round that is not completed
       */
      async function findActivePlayoffSeriesForAlias(db, alias) {
        const ref = collection(db, "playoffSeries");
        const q = query(
          ref,
          where("aliases", "array-contains", alias),
          where("status", "in", ["pending", "active"])
        );
        const snap = await getDocs(q);

        if (snap.empty) return null;

        // Find earliest round that's not completed
        let best = null;
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (!best) {
            best = docSnap;
          } else {
            const bd = best.data();
            if ((d.round || 0) < (bd.round || 0)) {
              best = docSnap;
            }
          }
        });

        return best;
      }

      /**
       * Join the playoff queue and attempt to create match
       */
      async function joinPlayoffMatchQueue(
        db,
        seriesDoc,
        myAlias,
        myDisplayName,
        oppAlias,
        oppDisplayName,
        clientId
      ) {
        const seriesId = seriesDoc.id;
        const series = seriesDoc.data();

        // Use a single match document per series
        const matchRef = doc(collection(db, "playoffMatches"), seriesId);

        // Check if match already exists
        const matchSnap = await getDoc(matchRef);

        if (matchSnap.exists()) {
          // Match already created, just listen to it
          playoffJoinStatus.textContent = "Joining existing match...";
          listenToPlayoffMatch(db, matchRef, seriesDoc, myAlias, myDisplayName);
        } else {
          // Try to create the match
          await createPlayoffMatch(
            db,
            matchRef,
            seriesDoc,
            myAlias,
            myDisplayName,
            oppAlias,
            oppDisplayName,
            clientId
          );
        }
      }

      /**
       * Create a new playoff match document
       */
      async function createPlayoffMatch(
        db,
        matchRef,
        seriesDoc,
        myAlias,
        myDisplayName,
        oppAlias,
        oppDisplayName,
        clientId
      ) {
        const series = seriesDoc.data();
        const seriesId = seriesDoc.id;

        // Determine who is higher seed (assume first in aliases array is higher seed)
        const aliases = series.aliases || [];
        const higherAlias = aliases[0];
        const lowerAlias = aliases[1];

        const higherDisplayName =
          higherAlias === myAlias ? myDisplayName : oppDisplayName;
        const lowerDisplayName =
          lowerAlias === myAlias ? myDisplayName : oppDisplayName;

        const isHigher = myAlias === higherAlias;

        // Get a quiz URL (will be shown only to higher seed initially)
        const quizUrl = await getRandomPlayoffQuizUrl(db);

        const matchData = {
          seriesId: seriesId,
          round: series.round || 1,
          matchIndex: series.matchIndex || 0,
          status: "waiting_for_veto", // waiting for higher seed to veto or accept
          createdAt: serverTimestamp(),

          higherAlias: higherAlias,
          higherDisplayName: higherDisplayName,
          higherClientId: isHigher ? clientId : null,
          higherJoined: isHigher,

          lowerAlias: lowerAlias,
          lowerDisplayName: lowerDisplayName,
          lowerClientId: !isHigher ? clientId : null,
          lowerJoined: !isHigher,

          quizUrl: quizUrl,
          vetoDecisionMade: false,
          vetoUsed: false,

          higherScore: null,
          lowerScore: null,

          winnerAlias: null,
          completedAt: null,
        };

        try {
          // Use a transaction to create match and update series atomically
          await runTransaction(db, async (transaction) => {
            // Check if match already exists
            const matchSnap = await transaction.get(matchRef);
            if (matchSnap.exists()) {
              // Someone else already created it, just return
              return;
            }

            // Create the match
            transaction.set(matchRef, matchData);

            // Update series status
            transaction.update(doc(collection(db, "playoffSeries"), seriesId), {
              status: "active",
              matchId: matchRef.id,
            });
          });

          playoffJoinStatus.textContent =
            "Match created! Waiting for opponent...";

          // Start listening
          listenToPlayoffMatch(db, matchRef, seriesDoc, myAlias, myDisplayName);
        } catch (err) {
          if (err.code === "permission-denied") {
            console.error(
              "Permission denied creating playoff match. Check Firestore rules."
            );
            playoffJoinStatus.textContent =
              "Permission denied. Please sign in as admin or check Firestore rules.";
          } else {
            console.error("Error creating playoff match", err);
            playoffJoinStatus.textContent =
              "Error creating match: " + err.message;
          }
        }
      }

      /**
       * Listen to playoff match updates
       */
      function listenToPlayoffMatch(
        db,
        matchRef,
        seriesDoc,
        myAlias,
        myDisplayName
      ) {
        // Clean up previous listener
        if (playoffCurrentMatchUnsub) {
          playoffCurrentMatchUnsub();
          playoffCurrentMatchUnsub = null;
        }

        playoffCurrentMatchUnsub = onSnapshot(
          matchRef,
          async (snap) => {
            if (!snap.exists()) {
              playoffJoinStatus.textContent = "Match was removed.";
              return;
            }

            const match = snap.data();
            const isHigherSeed = match.higherAlias === myAlias;
            const mySide = isHigherSeed ? "higher" : "lower";
            const oppSide = isHigherSeed ? "lower" : "higher";

            // Update join status if opponent hasn't joined yet
            const oppJoined = match[`${oppSide}Joined`];
            if (!oppJoined) {
              playoffJoinStatus.textContent = "Waiting for opponent to join...";
            } else {
              playoffJoinStatus.textContent = "Both players joined!";
            }

            // Update match document with my client ID if not set
            if (!match[`${mySide}ClientId`] || !match[`${mySide}Joined`]) {
              const clientId = getOrCreateHeadToHeadClientId();
              try {
                await updateDoc(matchRef, {
                  [`${mySide}ClientId`]: clientId,
                  [`${mySide}Joined`]: true,
                });
              } catch (err) {
                if (err.code === "permission-denied") {
                  console.error("Permission denied updating match join status");
                  // Continue anyway - the match can still work
                } else {
                  console.error("Error updating match join status", err);
                }
              }
            }

            // Handle veto phase (only higher seed sees quiz initially)
            if (match.status === "waiting_for_veto") {
              if (isHigherSeed && oppJoined) {
                // Show veto UI to higher seed
                showPlayoffVetoUI(matchRef, match, myAlias);
              } else if (!isHigherSeed) {
                // Lower seed waits
                showPlayoffWaitingForVeto(match);
              }
            }

            // Handle active match (after veto decision)
            if (match.status === "active") {
              showPlayoffActiveMatch(matchRef, match, myAlias, mySide);
            }

            // Handle completed match
            if (match.status === "completed") {
              showPlayoffMatchResult(match, myAlias);

              // If there's a winner, check if we need to create next round match
              if (match.winnerAlias) {
                await advanceWinnerToNextRound(db, seriesDoc, match);
              }
            }
          },
          (err) => {
            // Error handler for the listener
            if (err.code === "permission-denied") {
              console.error("Permission denied listening to playoff match");
              playoffJoinStatus.textContent =
                "Permission denied. Check Firestore rules.";
            } else {
              console.error("Error listening to playoff match", err);
              playoffJoinStatus.textContent = "Error loading match.";
            }
          }
        );

        // Store match data for score submission
        playoffMyMatchData = {
          matchRef: matchRef,
          myAlias: myAlias,
          seriesDoc: seriesDoc,
        };
      }

      /**
       * Show veto UI to higher seed
       */
      function showPlayoffVetoUI(matchRef, match, myAlias) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.add("d-none");
        h2hResultCard.classList.add("d-none");

        h2hYouName.textContent = match.higherDisplayName;
        h2hYouAlias.textContent = match.higherAlias;
        h2hOppName.textContent = match.lowerDisplayName;
        h2hOppAlias.textContent = match.lowerAlias;
        h2hQuizLink.href = match.quizUrl;
        h2hQuizLink.textContent = match.quizUrl;

        if (h2hVetoBtn && !match.vetoDecisionMade) {
          h2hVetoBtn.classList.remove("d-none");
          h2hVetoBtn.disabled = false;
          h2hVetoBtn.textContent = "Veto this quiz";

          // Add accept button
          let acceptBtn = document.getElementById("h2h-accept-btn");
          if (!acceptBtn) {
            acceptBtn = document.createElement("button");
            acceptBtn.id = "h2h-accept-btn";
            acceptBtn.className = "btn btn-success btn-sm ms-2";
            acceptBtn.textContent = "Accept this quiz";
            h2hVetoBtn.parentElement.appendChild(acceptBtn);
          }
          acceptBtn.classList.remove("d-none");
          acceptBtn.disabled = false;

          // Veto handler
          h2hVetoBtn.onclick = async (e) => {
            e.preventDefault();
            h2hVetoBtn.disabled = true;
            acceptBtn.disabled = true;

            try {
              const newQuizUrl = await getRandomPlayoffQuizUrl(db);
              await updateDoc(matchRef, {
                quizUrl: newQuizUrl,
                vetoUsed: true,
                vetoDecisionMade: true,
                status: "active",
              });
              playoffJoinStatus.textContent = "Veto used! New quiz assigned.";
            } catch (err) {
              console.error("Error using veto", err);
              h2hVetoBtn.disabled = false;
              acceptBtn.disabled = false;
            }
          };

          // Accept handler
          acceptBtn.onclick = async (e) => {
            e.preventDefault();
            h2hVetoBtn.disabled = true;
            acceptBtn.disabled = true;

            try {
              await updateDoc(matchRef, {
                vetoDecisionMade: true,
                status: "active",
              });
              playoffJoinStatus.textContent = "Quiz accepted!";
            } catch (err) {
              console.error("Error accepting quiz", err);
              h2hVetoBtn.disabled = false;
              acceptBtn.disabled = false;
            }
          };
        }

        playoffJoinStatus.textContent =
          "Review the quiz and decide whether to veto or accept.";
      }

      /**
       * Show waiting message to lower seed during veto phase
       */
      function showPlayoffWaitingForVeto(match) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.add("d-none");
        h2hResultCard.classList.add("d-none");

        h2hYouName.textContent = match.lowerDisplayName;
        h2hYouAlias.textContent = match.lowerAlias;
        h2hOppName.textContent = match.higherDisplayName;
        h2hOppAlias.textContent = match.higherAlias;
        h2hQuizLink.textContent = "Waiting for opponent to review quiz...";
        h2hQuizLink.removeAttribute("href");

        if (h2hVetoBtn) h2hVetoBtn.classList.add("d-none");
        const acceptBtn = document.getElementById("h2h-accept-btn");
        if (acceptBtn) acceptBtn.classList.add("d-none");

        playoffJoinStatus.textContent =
          "Waiting for higher seed to make veto decision...";
      }

      /**
       * Show active match (after veto decision)
       */
      function showPlayoffActiveMatch(matchRef, match, myAlias, mySide) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.remove("d-none");
        h2hResultCard.classList.add("d-none");

        const isHigher = mySide === "higher";

        h2hYouName.textContent = isHigher
          ? match.higherDisplayName
          : match.lowerDisplayName;
        h2hYouAlias.textContent = isHigher
          ? match.higherAlias
          : match.lowerAlias;
        h2hOppName.textContent = isHigher
          ? match.lowerDisplayName
          : match.higherDisplayName;
        h2hOppAlias.textContent = isHigher
          ? match.lowerAlias
          : match.higherAlias;
        h2hQuizLink.href = match.quizUrl;
        h2hQuizLink.textContent = match.quizUrl;

        // Hide veto buttons
        if (h2hVetoBtn) h2hVetoBtn.classList.add("d-none");
        const acceptBtn = document.getElementById("h2h-accept-btn");
        if (acceptBtn) acceptBtn.classList.add("d-none");

        // Enable score submission
        const myScore = match[`${mySide}Score`];
        if (myScore) {
          h2hScoreInput.value = myScore.rawScore;
          h2hTimeInput.value = formatSecondsAsMMSS(myScore.timeLeftSeconds);
          h2hScoreInput.disabled = true;
          h2hTimeInput.disabled = true;
          document.getElementById("h2h-score-submit-btn").disabled = true;
          h2hScoreStatus.textContent =
            "Score submitted. Waiting for opponent...";
        } else {
          h2hScoreInput.disabled = false;
          h2hTimeInput.disabled = false;
          h2hScoreInput.value = "";
          h2hTimeInput.value = "";
          document.getElementById("h2h-score-submit-btn").disabled = false;
          h2hScoreStatus.textContent = "Play the quiz and submit your score.";
        }

        playoffJoinStatus.textContent = match.vetoUsed
          ? "Veto was used. Quiz is now active!"
          : "Quiz accepted! Take the quiz and submit your score.";
      }

      /**
       * Show match result
       */
      function showPlayoffMatchResult(match, myAlias) {
        h2hResultCard.classList.remove("d-none");

        const isWinner = match.winnerAlias === myAlias;
        const isHigher = match.higherAlias === myAlias;
        const mySide = isHigher ? "higher" : "lower";
        const oppSide = isHigher ? "lower" : "higher";

        const myScore = match[`${mySide}Score`];
        const oppScore = match[`${oppSide}Score`];

        let summary;
        if (isWinner) {
          summary = `üéâ You won and advance to the next round!`;
        } else {
          summary = `You lost. Better luck next time!`;
        }

        h2hResultSummary.textContent = summary;

        const detailLines = [];
        if (myScore) {
          detailLines.push(
            `Your score: ${myScore.rawScore} (${Math.round(
              myScore.pct * 100
            )}%), time: ${formatSecondsAsMMSS(myScore.timeLeftSeconds)}`
          );
        }
        if (oppScore) {
          detailLines.push(
            `Opponent: ${oppScore.rawScore} (${Math.round(
              oppScore.pct * 100
            )}%), time: ${formatSecondsAsMMSS(oppScore.timeLeftSeconds)}`
          );
        }

        h2hResultDetail.innerHTML = "";
        detailLines.forEach((t) => {
          const li = document.createElement("li");
          li.textContent = t;
          h2hResultDetail.appendChild(li);
        });

        playoffJoinStatus.textContent = "Match completed!";
      }

      /**
       * Submit playoff score
       */
      if (h2hScoreForm) {
        h2hScoreForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          if (!playoffMyMatchData) {
            h2hScoreStatus.textContent = "No active playoff match.";
            return;
          }

          const { matchRef, myAlias } = playoffMyMatchData;

          const parsed = parseScoreString(h2hScoreInput.value);
          if (!parsed) {
            h2hScoreStatus.textContent =
              "Invalid score format. Use num/den (e.g., 7/9).";
            return;
          }

          const seconds = parseTimeString(h2hTimeInput.value);
          if (seconds === null) {
            h2hScoreStatus.textContent =
              "Invalid time format. Use mm:ss (e.g., 01:23).";
            return;
          }

          const scoreObj = {
            ...parsed,
            timeLeftSeconds: seconds,
            submittedAt: serverTimestamp(),
          };

          try {
            h2hScoreStatus.textContent = "Submitting score...";

            // Determine which side I am
            const matchSnap = await getDoc(matchRef);
            if (!matchSnap.exists()) {
              h2hScoreStatus.textContent = "Match not found.";
              return;
            }

            const match = matchSnap.data();
            const isHigher = match.higherAlias === myAlias;
            const mySide = isHigher ? "higher" : "lower";

            await updateDoc(matchRef, {
              [`${mySide}Score`]: scoreObj,
            });

            h2hScoreInput.disabled = true;
            h2hTimeInput.disabled = true;
            document.getElementById("h2h-score-submit-btn").disabled = true;
            h2hScoreStatus.textContent = "Score submitted!";

            // Try to resolve match
            await resolvePlayoffMatch(db, matchRef);
          } catch (err) {
            console.error("Error submitting playoff score", err);
            h2hScoreStatus.textContent = "Error submitting score.";
          }
        });
      }

      /**
       * Resolve playoff match when both scores are in
       */
      async function resolvePlayoffMatch(db, matchRef) {
        const matchSnap = await getDoc(matchRef);
        if (!matchSnap.exists()) return;

        const match = matchSnap.data();
        const higherScore = match.higherScore;
        const lowerScore = match.lowerScore;

        // Need both scores
        if (!higherScore || !lowerScore) return;

        // Already resolved
        if (match.status === "completed") return;

        // Determine winner
        let winnerAlias = null;

        const higherPct = higherScore.pct || 0;
        const lowerPct = lowerScore.pct || 0;

        if (higherPct > lowerPct) {
          winnerAlias = match.higherAlias;
        } else if (lowerPct > higherPct) {
          winnerAlias = match.lowerAlias;
        } else {
          // Tie on percentage, use time
          const higherTime = higherScore.timeLeftSeconds || 0;
          const lowerTime = lowerScore.timeLeftSeconds || 0;

          if (higherTime > lowerTime) {
            winnerAlias = match.higherAlias;
          } else if (lowerTime > higherTime) {
            winnerAlias = match.lowerAlias;
          } else {
            // Still tied - higher seed wins
            winnerAlias = match.higherAlias;
          }
        }

        // Update match
        await updateDoc(matchRef, {
          status: "completed",
          winnerAlias: winnerAlias,
          completedAt: serverTimestamp(),
        });

        // Update series
        await updateDoc(doc(collection(db, "playoffSeries"), match.seriesId), {
          status: "completed",
          winnerAlias: winnerAlias,
        });
      }

      /**
       * Advance winner to next round - creates or updates the next round match
       */
      async function advanceWinnerToNextRound(db, seriesDoc, matchResult) {
        const series = seriesDoc.data();
        const currentRound = series.round || 1;
        const currentMatchIndex = series.matchIndex || 0;
        const winnerAlias = matchResult.winnerAlias;
        const winnerDisplayName = matchResult.winnerDisplayName || winnerAlias;

        // Get winner's seed
        const currentSeeds = series.seeds || [null, null];
        const aliases = series.aliases || [];
        const winnerIndex = aliases.indexOf(winnerAlias);
        const winnerSeed = winnerIndex >= 0 ? currentSeeds[winnerIndex] : null;

        console.log(
          `üèÜ Winner ${winnerAlias} (seed ${winnerSeed}) from Round ${currentRound}, Match ${currentMatchIndex}`
        );

        // Calculate next round parameters
        const nextRound = currentRound + 1;
        const nextMatchIndex = Math.floor(currentMatchIndex / 2);

        // Determine which position in the next match (top or bottom)
        // Even matchIndex (0, 2, 4...) goes to position 0, odd (1, 3, 5...) goes to position 1
        const positionInNextMatch = currentMatchIndex % 2;

        console.log(
          `‚û°Ô∏è Should advance to Round ${nextRound}, Match ${nextMatchIndex}, Position ${positionInNextMatch}`
        );

        // Find if next round match already exists
        const nextSeriesRef = collection(db, "playoffSeries");
        const q = query(
          nextSeriesRef,
          where("round", "==", nextRound),
          where("matchIndex", "==", nextMatchIndex)
        );

        try {
          const snap = await getDocs(q);

          if (snap.empty) {
            // Create new next round match
            console.log(
              `‚ú® Creating new match for Round ${nextRound}, Match ${nextMatchIndex}`
            );

            const newMatchRef = doc(nextSeriesRef);

            const newAliases = ["TBD", "TBD"];
            const newSeeds = [null, null];

            newAliases[positionInNextMatch] = winnerAlias;
            newSeeds[positionInNextMatch] = winnerSeed;

            await setDoc(newMatchRef, {
              round: nextRound,
              matchIndex: nextMatchIndex,
              aliases: newAliases,
              seeds: newSeeds,
              status: "pending",
              winnerAlias: null,
              createdAt: serverTimestamp(),
            });

            console.log(`‚úÖ Created: ${newAliases[0]} vs ${newAliases[1]}`);
          } else {
            // Update existing next round match
            const nextMatchDoc = snap.docs[0];
            const nextMatch = nextMatchDoc.data();
            const currentAliases = nextMatch.aliases || ["TBD", "TBD"];
            const currentSeeds = nextMatch.seeds || [null, null];

            console.log(
              `üìù Updating existing match: ${currentAliases[0]} vs ${currentAliases[1]}`
            );

            const updatedAliases = [...currentAliases];
            const updatedSeeds = [...currentSeeds];

            updatedAliases[positionInNextMatch] = winnerAlias;
            updatedSeeds[positionInNextMatch] = winnerSeed;

            const updates = {
              aliases: updatedAliases,
              seeds: updatedSeeds,
            };

            // If both slots are now filled, mark as ready to play
            if (updatedAliases[0] !== "TBD" && updatedAliases[1] !== "TBD") {
              updates.status = "pending";
              console.log(
                `üéÆ Match is now ready: ${updatedAliases[0]} vs ${updatedAliases[1]}`
              );
            }

            await updateDoc(nextMatchDoc.ref, updates);

            console.log(
              `‚úÖ Updated: ${updatedAliases[0]} vs ${updatedAliases[1]}`
            );
          }
        } catch (err) {
          console.error("‚ùå Error advancing winner to next round:", err);
          throw err;
        }
      }

      // ============================================================================
      // DYNAMIC PLAYOFF BRACKET VISUALIZATION
      // ============================================================================

      const playoffsBracketContainer =
        document.getElementById("playoffs-bracket");
      let bracketUnsubscribe = null;

      /**
       * Start listening to playoff series and render bracket dynamically
       */
      function startBracketListener() {
        if (bracketUnsubscribe) {
          bracketUnsubscribe();
        }

        const seriesRef = collection(db, "playoffSeries");
        bracketUnsubscribe = onSnapshot(seriesRef, (snap) => {
          const allSeries = [];
          snap.forEach((doc) => {
            allSeries.push({ id: doc.id, ...doc.data() });
          });
          renderBracket(allSeries);
        });
      }

      /**
       * Render the playoff bracket using React
       * @param {Array} allSeries - Array of series/match objects
       * @param {boolean} isProjected - If true, use displayNames from series objects
       */
      async function renderBracket(allSeries, isProjected = false) {
        if (!playoffsBracketContainer) return;

        if (allSeries.length === 0) {
          playoffsBracketContainer.innerHTML =
            '<p class="text-center text-muted">No playoff matches yet.</p>';
          return;
        }

        let displayNames = {};

        if (isProjected) {
          // For projected brackets, extract displayNames from series data
          allSeries.forEach((series) => {
            const aliases = series.aliases || [];
            const names = series.displayNames || [];
            aliases.forEach((alias, idx) => {
              if (alias && alias !== "TBD" && alias !== "BYE") {
                displayNames[alias] = names[idx] || alias;
              }
            });
          });
        } else {
          // Fetch all display names from Firestore
          const allAliases = new Set();
          allSeries.forEach((series) => {
            const aliases = series.aliases || [];
            aliases.forEach((alias) => {
              if (alias !== "TBD") allAliases.add(alias);
            });
          });

          // Fetch display names from points collection
          for (const alias of allAliases) {
            try {
              const pointsDoc = await getDoc(
                doc(collection(db, "points"), alias)
              );
              if (pointsDoc.exists()) {
                const data = pointsDoc.data();
                displayNames[alias] = data.displayName || alias;
              } else {
                displayNames[alias] = alias;
              }
            } catch (err) {
              console.error(`Error fetching data for ${alias}`, err);
              displayNames[alias] = alias;
            }
          }
        }

        // Render with React
        const root = ReactDOM.createRoot(playoffsBracketContainer);
        root.render(
          React.createElement(PlayoffBracket, {
            matches: allSeries,
            displayNames: displayNames,
            darkMode: true,
            isProjected: isProjected,
          })
        );
      }

      // ============== REACT PLAYOFF BRACKET COMPONENT ==============

      function PlayoffBracket({ matches, displayNames, darkMode }) {
        const rounds = {};
        let maxRound = 0;

        matches.forEach((match) => {
          const round = match.round || 1;
          if (!rounds[round]) rounds[round] = [];
          rounds[round].push(match);
          if (round > maxRound) maxRound = round;
        });

        const sortedRoundNumbers = Object.keys(rounds)
          .map(Number)
          .sort((a, b) => a - b);

        sortedRoundNumbers.forEach((roundNum) => {
          rounds[roundNum].sort(
            (a, b) => (a.matchIndex || 0) - (b.matchIndex || 0)
          );
        });

        // Calculate total rounds based on first round match count
        // 16 matches in R1 = 32 teams = 5 rounds (R32, S16, E8, F4, Championship)
        // 8 matches in R1 = 16 teams = 4 rounds (S16, E8, F4, Championship)
        // 4 matches in R1 = 8 teams = 3 rounds (E8, F4, Championship)
        const firstRoundMatches = rounds[1] ? rounds[1].length : 0;

        // Calculate total rounds: log2(teams) where teams = firstRoundMatches * 2
        // 16 matches = 32 teams = log2(32) = 5 rounds
        const totalExpectedRounds =
          firstRoundMatches > 0 ? Math.log2(firstRoundMatches * 2) : maxRound;

        const getRoundName = (roundNum) => {
          // Calculate rounds remaining based on TOTAL expected rounds
          const roundsRemaining = totalExpectedRounds - roundNum;
          if (roundsRemaining === 0) return "Championship";
          if (roundsRemaining === 1) return "Final Four";
          if (roundsRemaining === 2) return "Elite Eight";
          if (roundsRemaining === 3) return "Sweet Sixteen";
          if (roundsRemaining === 4) return "Round of 32";
          if (roundsRemaining === 5) return "Round of 64";
          return `Round ${roundNum}`;
        };

        // Calculate the height of a single match card
        const MATCH_HEIGHT = 70; // Height of one match card in pixels
        const MATCH_GAP = 10; // Gap between matches in the same round

        const theme = {
          bg: darkMode ? "#1a1d23" : "#ffffff",
          cardBg: darkMode ? "#282c34" : "#f8f9fa",
          border: darkMode ? "#3d4250" : "#dee2e6",
          text: darkMode ? "#e9ecef" : "#212529",
          textMuted: darkMode ? "#8b949e" : "#6c757d",
          winner: darkMode ? "#3fb97a" : "#198754",
          winnerBg: darkMode ? "rgba(63, 185, 122, 0.2)" : "#d1e7dd",
          active: darkMode ? "#4493f8" : "#0d6efd",
          connector: darkMode ? "#3d4250" : "#dee2e6",
        };

        if (matches.length === 0) {
          return React.createElement(
            "div",
            {
              style: {
                padding: "40px",
                textAlign: "center",
                color: theme.textMuted,
                backgroundColor: theme.bg,
                borderRadius: "12px",
              },
            },
            "No playoff matches yet."
          );
        }

        // Generate all rounds including future ones with TBD placeholders
        const allRounds = [];
        for (let r = 1; r <= totalExpectedRounds; r++) {
          if (rounds[r]) {
            allRounds.push({ roundNum: r, matches: rounds[r] });
          } else {
            // Generate placeholder matches for this round
            // Number of matches = firstRoundMatches / 2^(r-1)
            const matchCount = Math.max(
              1,
              Math.floor(firstRoundMatches / Math.pow(2, r - 1))
            );
            const placeholders = [];
            for (let m = 0; m < matchCount; m++) {
              placeholders.push({
                id: `placeholder-${r}-${m}`,
                round: r,
                matchIndex: m,
                aliases: ["TBD", "TBD"],
                seeds: [null, null],
                status: "pending",
                winnerAlias: null,
              });
            }
            allRounds.push({ roundNum: r, matches: placeholders });
          }
        }

        return React.createElement(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              overflowX: "auto",
              padding: "20px",
              backgroundColor: theme.bg,
              borderRadius: "12px",
              alignItems: "flex-start",
            },
          },
          allRounds.map((roundData, roundIndex) => {
            const roundNum = roundData.roundNum;
            const roundMatches = roundData.matches;

            // Calculate spacing for proper bracket alignment
            // Each round should have matches centered between the two matches that feed into it
            const matchesInRound = roundMatches.length;
            const spacingMultiplier = Math.pow(2, roundIndex);
            const totalMatchHeight = MATCH_HEIGHT + MATCH_GAP;

            // Gap between matches in this round
            const gapBetweenMatches =
              totalMatchHeight * spacingMultiplier - MATCH_HEIGHT;

            // Initial offset to center this round's matches with the previous round
            const initialOffset =
              (totalMatchHeight * (spacingMultiplier - 1)) / 2;

            return React.createElement(
              "div",
              {
                key: roundNum,
                style: {
                  display: "flex",
                  flexDirection: "column",
                  minWidth: "180px",
                  flexShrink: 0,
                  marginRight: "20px",
                },
              },
              [
                // Round Title
                React.createElement(
                  "div",
                  {
                    key: "title",
                    style: {
                      textAlign: "center",
                      fontWeight: "600",
                      fontSize: "0.75rem",
                      textTransform: "uppercase",
                      letterSpacing: "0.5px",
                      color: theme.winner,
                      marginBottom: "12px",
                      padding: "6px",
                    },
                  },
                  getRoundName(roundNum)
                ),

                // Matches Container
                React.createElement(
                  "div",
                  {
                    key: "matches",
                    style: {
                      display: "flex",
                      flexDirection: "column",
                      paddingTop: `${initialOffset}px`,
                    },
                  },
                  roundMatches.map((match, matchIndex) =>
                    React.createElement(
                      "div",
                      {
                        key: match.id || `${roundNum}-${matchIndex}`,
                        style: {
                          marginBottom:
                            matchIndex < roundMatches.length - 1
                              ? `${gapBetweenMatches}px`
                              : "0",
                        },
                      },
                      React.createElement(MatchCard, {
                        match: match,
                        displayNames: displayNames,
                        theme: theme,
                        showConnector: roundIndex < allRounds.length - 1,
                      })
                    )
                  )
                ),
              ]
            );
          })
        );
      }

      function MatchCard({ match, displayNames, theme, showConnector }) {
        const aliases = match.aliases || [];
        const seeds = match.seeds || [null, null];
        const winner = match.winnerAlias;
        const isCompleted = match.status === "completed";
        const isActive = match.status === "active";

        const player1Alias = aliases[0] || "TBD";
        const player2Alias = aliases[1] || "TBD";
        const player1Name =
          player1Alias === "TBD"
            ? "TBD"
            : displayNames[player1Alias] || player1Alias;
        const player2Name =
          player2Alias === "TBD"
            ? "TBD"
            : displayNames[player2Alias] || player2Alias;

        return React.createElement(
          "div",
          {
            style: {
              backgroundColor: theme.cardBg,
              border: `2px solid ${
                isActive
                  ? theme.active
                  : isCompleted
                  ? theme.winner
                  : theme.border
              }`,
              borderRadius: "6px",
              padding: "2px",
              position: "relative",
              boxShadow: isActive ? `0 0 12px ${theme.active}40` : "none",
              height: "66px", // Fixed height for consistent bracket alignment
              boxSizing: "border-box",
            },
          },
          [
            React.createElement(PlayerRow, {
              key: "p1",
              name: player1Name,
              seed: seeds[0],
              isWinner: winner === player1Alias,
              isLoser:
                winner && winner !== player1Alias && player1Alias !== "TBD",
              isTBD: player1Alias === "TBD",
              theme: theme,
            }),
            React.createElement(PlayerRow, {
              key: "p2",
              name: player2Name,
              seed: seeds[1],
              isWinner: winner === player2Alias,
              isLoser:
                winner && winner !== player2Alias && player2Alias !== "TBD",
              isTBD: player2Alias === "TBD",
              theme: theme,
            }),
            // Horizontal connector line to next round
            showConnector &&
              React.createElement("div", {
                key: "connector",
                style: {
                  position: "absolute",
                  right: "-21px",
                  top: "50%",
                  width: "20px",
                  height: "2px",
                  backgroundColor: theme.connector,
                  transform: "translateY(-50%)",
                },
              }),
          ]
        );
      }

      function PlayerRow({ name, seed, isWinner, isLoser, isTBD, theme }) {
        return React.createElement(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              padding: "6px 8px",
              margin: "1px",
              borderRadius: "3px",
              fontSize: "0.8rem",
              backgroundColor: isWinner ? theme.winnerBg : "transparent",
              color: isWinner
                ? theme.winner
                : isLoser
                ? theme.textMuted
                : isTBD
                ? theme.textMuted
                : theme.text,
              fontWeight: isWinner ? "600" : "400",
              fontStyle: isTBD ? "italic" : "normal",
              opacity: isLoser ? 0.5 : 1,
              height: "28px",
              boxSizing: "border-box",
            },
          },
          [
            React.createElement(
              "span",
              {
                key: "info",
                style: { display: "flex", alignItems: "center", gap: "6px" },
              },
              [
                seed &&
                  React.createElement(
                    "span",
                    {
                      key: "seed",
                      style: {
                        fontSize: "0.7rem",
                        opacity: 0.7,
                        minWidth: "16px",
                        fontWeight: "600",
                      },
                    },
                    seed
                  ),
                React.createElement(
                  "span",
                  {
                    key: "name",
                    style: {
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      whiteSpace: "nowrap",
                      maxWidth: "120px",
                    },
                  },
                  name
                ),
              ]
            ),
            isWinner &&
              React.createElement(
                "span",
                {
                  key: "check",
                  style: { color: theme.winner },
                },
                "‚úì"
              ),
          ]
        );
      }

      // Start the bracket listener when the playoffs tab is shown
      const playoffsTab = document.querySelector(
        '[data-bs-target="#tab-playoffs"]'
      );
      if (playoffsTab) {
        playoffsTab.addEventListener("shown.bs.tab", () => {
          // If playoffs ended, show projected; otherwise show real bracket
          if (__playoffsEnded) {
            showProjectedBracket();
          } else {
            startBracketListener();
          }
        });
      }

      // Also start on page load if playoffs are finalized
      onSnapshot(playoffsConfigRef, (snap) => {
        const data = snap.exists() ? snap.data() : {};
        __playoffsFinalized = !!data.finalized;
        __playoffsEnded = !!data.ended;
        updatePlayoffsUIFromFlag();

        // Start bracket listener if playoffs are active (but not ended)
        if (__playoffsFinalized && !__playoffsEnded) {
          startBracketListener();
        } else if (__playoffsEnded) {
          showProjectedBracket();
        }
      });

      // ============================================================================
      // ADMIN: Manual Playoff Result Entry
      // ============================================================================

      const manualPlayoffForm = document.getElementById(
        "manual-playoff-result-form"
      );
      const manualPlayoffStatus = document.getElementById(
        "manual-playoff-status"
      );
      const playoffMatchesBody = document.getElementById(
        "playoff-matches-body"
      );

      // Load and display all playoff series
      async function loadPlayoffMatches() {
        if (!playoffMatchesBody) return;

        const seriesRef = collection(db, "playoffSeries");
        const q = query(
          seriesRef,
          orderBy("round", "asc"),
          orderBy("matchIndex", "asc")
        );
        const snap = await getDocs(q);

        playoffMatchesBody.innerHTML = "";

        if (snap.empty) {
          playoffMatchesBody.innerHTML =
            '<tr><td colspan="7" class="text-center">No playoff series found</td></tr>';
          return;
        }

        snap.forEach((docSnap) => {
          const series = docSnap.data();
          const tr = document.createElement("tr");

          const aliases = series.aliases || [];
          const player1 = aliases[0] || "TBD";
          const player2 = aliases[1] || "TBD";
          const status = series.status || "pending";
          const winner = series.winnerAlias || "-";

          tr.innerHTML = `
      <td>${series.round || "-"}</td>
      <td>${series.matchIndex || "0"}</td>
      <td>${player1}</td>
      <td>${player2}</td>
      <td>
        <span class="badge ${
          status === "completed"
            ? "bg-success"
            : status === "active"
            ? "bg-primary"
            : "bg-secondary"
        }">
          ${status}
        </span>
      </td>
      <td>${winner}</td>
      <td>
        ${
          status !== "completed"
            ? `
          <button class="btn btn-sm btn-outline-primary set-winner-btn" 
                  data-series-id="${docSnap.id}"
                  data-player1="${player1}"
                  data-player2="${player2}">
            Set Winner
          </button>
        `
            : "-"
        }
      </td>
    `;

          playoffMatchesBody.appendChild(tr);
        });

        // Add click handlers to "Set Winner" buttons
        document.querySelectorAll(".set-winner-btn").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            const seriesId = e.target.dataset.seriesId;
            const player1 = e.target.dataset.player1;
            const player2 = e.target.dataset.player2;

            const winner = prompt(
              `Who won this match?\n\n1. ${player1}\n2. ${player2}\n\nEnter the winner's alias:`
            );
            if (!winner) return;

            const winnerAlias = winner.trim().toLowerCase();

            try {
              await setPlayoffWinner(seriesId, winnerAlias);
              alert("Winner set successfully!");
              loadPlayoffMatches(); // Reload table
            } catch (err) {
              console.error("Error setting winner", err);
              alert("Error: " + err.message);
            }
          });
        });
      }

      // Manual form submission
      if (manualPlayoffForm) {
        manualPlayoffForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          const round = parseInt(
            document.getElementById("playoff-round").value,
            10
          );
          const matchIndex = parseInt(
            document.getElementById("playoff-match-index").value,
            10
          );
          const winnerAlias = document
            .getElementById("playoff-winner-alias")
            .value.trim()
            .toLowerCase();

          if (!winnerAlias) {
            manualPlayoffStatus.textContent = "Please enter a winner alias.";
            return;
          }

          try {
            manualPlayoffStatus.textContent = "Finding match...";

            // Find the series by round and matchIndex
            const seriesRef = collection(db, "playoffSeries");
            const q = query(
              seriesRef,
              where("round", "==", round),
              where("matchIndex", "==", matchIndex)
            );
            const snap = await getDocs(q);

            if (snap.empty) {
              manualPlayoffStatus.textContent = `No match found for Round ${round}, Match ${matchIndex}.`;
              return;
            }

            const seriesDoc = snap.docs[0];
            const series = seriesDoc.data();
            const aliases = series.aliases || [];

            if (!aliases.includes(winnerAlias)) {
              manualPlayoffStatus.textContent = `Winner "${winnerAlias}" is not in this matchup. Players: ${aliases.join(
                ", "
              )}`;
              return;
            }

            manualPlayoffStatus.textContent = "Setting winner...";
            await setPlayoffWinner(seriesDoc.id, winnerAlias);

            manualPlayoffStatus.textContent = `‚úÖ Winner set: ${winnerAlias} advances from Round ${round}, Match ${matchIndex}`;
            manualPlayoffForm.reset();

            // Reload the table
            loadPlayoffMatches();
          } catch (err) {
            console.error("Error setting playoff winner", err);
            manualPlayoffStatus.textContent = "Error: " + err.message;
          }
        });
      }

      /**
       * Set the winner for a playoff series and advance them to next round
       */
      async function setPlayoffWinner(seriesId, winnerAlias) {
        console.log(
          `üéØ setPlayoffWinner called with seriesId=${seriesId}, winnerAlias=${winnerAlias}`
        );

        const seriesRef = doc(collection(db, "playoffSeries"), seriesId);
        const seriesSnap = await getDoc(seriesRef);

        if (!seriesSnap.exists()) {
          throw new Error("Series not found");
        }

        const series = seriesSnap.data();
        console.log(`üìã Series data:`, series);

        const aliases = series.aliases || [];

        if (!aliases.includes(winnerAlias)) {
          throw new Error(
            `Winner "${winnerAlias}" is not in this matchup. Players: ${aliases.join(
              ", "
            )}`
          );
        }

        // Validate that round and matchIndex exist
        if (series.round === undefined || series.matchIndex === undefined) {
          console.error("‚ùå Series is missing round or matchIndex!", series);
          throw new Error(
            `Series is missing round (${series.round}) or matchIndex (${series.matchIndex})`
          );
        }

        // Get winner's display name from points collection
        const winnerPointsDoc = await getDoc(
          doc(collection(db, "points"), winnerAlias)
        );
        const winnerDisplayName = winnerPointsDoc.exists()
          ? winnerPointsDoc.data().displayName || winnerAlias
          : winnerAlias;

        console.log(
          `üìù Updating series ${seriesId} with winner ${winnerAlias}`
        );

        // Update series
        await updateDoc(seriesRef, {
          status: "completed",
          winnerAlias: winnerAlias,
          winnerDisplayName: winnerDisplayName,
          completedAt: serverTimestamp(),
        });

        // If there's a match document, update it too
        const matchRef = doc(collection(db, "playoffMatches"), seriesId);
        const matchSnap = await getDoc(matchRef);

        if (matchSnap.exists()) {
          await updateDoc(matchRef, {
            status: "completed",
            winnerAlias: winnerAlias,
            completedAt: serverTimestamp(),
          });
        }

        // Advance winner to next round
        console.log(
          `üöÄ Advancing winner ${winnerAlias} from Round ${series.round}, Match ${series.matchIndex}`
        );

        try {
          await advanceWinnerToNextRound(db, seriesSnap, {
            winnerAlias,
            winnerDisplayName,
            round: series.round,
            matchIndex: series.matchIndex,
          });
          console.log(`‚úÖ Successfully advanced winner to next round`);
        } catch (advanceErr) {
          console.error(`‚ùå Error in advanceWinnerToNextRound:`, advanceErr);
          throw advanceErr;
        }
      }

      // Load playoff matches when admin tab is shown (only if user is admin)
      document
        .getElementById("admin-tab-btn")
        ?.addEventListener("click", () => {
          if (window.__isAdmin) {
            setTimeout(() => loadPlayoffMatches(), 100);
          }
        });

      // Also load on page load if admin
      window.addEventListener("load", () => {
        if (window.__isAdmin) {
          setTimeout(() => loadPlayoffMatches(), 500);
        }
      });

      /**
       * Get random playoff quiz URL
       */
      let playoffRecentQuizUrls = [];

      async function getRandomPlayoffQuizUrl(db) {
        const ref = collection(db, "playoffQuizzes");
        const snap = await getDocs(ref);

        const urls = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (d && d.url) urls.push(d.url);
        });

        if (!urls.length) {
          throw new Error("No playoff quizzes available");
        }

        // Avoid recent repeats
        let choice = null;
        for (let tries = 0; tries < 5; tries++) {
          const idx = Math.floor(Math.random() * urls.length);
          const candidate = urls[idx];
          if (!playoffRecentQuizUrls.includes(candidate)) {
            choice = candidate;
            break;
          }
        }
        if (!choice) {
          const idx = Math.floor(Math.random() * urls.length);
          choice = urls[idx];
        }

        playoffRecentQuizUrls.push(choice);
        if (playoffRecentQuizUrls.length > 10) {
          playoffRecentQuizUrls.shift();
        }

        return choice;
      }

      async function getRandomQuizUrl(db) {
        const quizzesRef = collection(db, "quizzes");
        const snap = await getDocs(quizzesRef);

        const urls = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (d && d.url) urls.push(d.url);
        });

        if (!urls.length) {
          throw new Error("No quizzes available");
        }

        // avoid recent repeats on this device
        let choice = null;
        for (let tries = 0; tries < 5; tries++) {
          const idx = Math.floor(Math.random() * urls.length);
          const candidate = urls[idx];
          if (!h2hRecentQuizUrls.includes(candidate)) {
            choice = candidate;
            break;
          }
        }
        if (!choice) {
          const idx = Math.floor(Math.random() * urls.length);
          choice = urls[idx];
        }

        h2hRecentQuizUrls.push(choice);
        if (h2hRecentQuizUrls.length > 10) {
          h2hRecentQuizUrls.shift();
        }

        return choice;
      }

      // ============================================================================
      // ADMIN: Initialize Playoff Bracket with Seeds
      // ============================================================================

      /**
       * Add seeds to existing playoff series based on points standings
       */
      async function addSeedsToPlayoffSeries() {
        try {
          // Get all players from points collection, sorted by points
          const pointsRef = collection(db, "points");
          const pointsSnap = await getDocs(
            query(pointsRef, orderBy("points", "desc"))
          );

          const seedMap = {};
          let seed = 1;
          pointsSnap.forEach((doc) => {
            seedMap[doc.id] = seed;
            seed++;
          });

          // Update all playoff series with seeds
          const seriesRef = collection(db, "playoffSeries");
          const seriesSnap = await getDocs(seriesRef);

          const batch = writeBatch(db);
          let updateCount = 0;

          seriesSnap.forEach((doc) => {
            const series = doc.data();
            const aliases = series.aliases || [];

            const player1Seed =
              aliases[0] !== "TBD" ? seedMap[aliases[0]] : null;
            const player2Seed =
              aliases[1] !== "TBD" ? seedMap[aliases[1]] : null;

            if (player1Seed || player2Seed) {
              batch.update(doc.ref, {
                seeds: [player1Seed, player2Seed],
              });
              updateCount++;
            }
          });

          if (updateCount > 0) {
            await batch.commit();
            console.log(`Updated ${updateCount} playoff series with seeds`);
            return `‚úÖ Added seeds to ${updateCount} matches`;
          } else {
            return "No matches needed seed updates";
          }
        } catch (err) {
          console.error("Error adding seeds", err);
          throw err;
        }
      }

      // Add button to admin panel to trigger seed setup
      const addSeedsBtn = document.getElementById("add-seeds-btn");
      if (addSeedsBtn) {
        addSeedsBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "Add seeds to all playoff matches based on current standings?"
            )
          )
            return;

          try {
            addSeedsBtn.disabled = true;
            addSeedsBtn.textContent = "Adding seeds...";
            const result = await addSeedsToPlayoffSeries();
            alert(result);
            loadPlayoffMatches(); // Refresh the table
          } catch (err) {
            alert("Error: " + err.message);
          } finally {
            addSeedsBtn.disabled = false;
            addSeedsBtn.textContent = "Add Seeds to Bracket";
          }
        });
      }

      // Reset & Initialize Bracket button
      const resetBracketBtn = document.getElementById("reset-bracket-btn");
      if (resetBracketBtn) {
        resetBracketBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "‚ö†Ô∏è WARNING: This will DELETE all playoff data and create a fresh bracket!\n\n" +
                "This will:\n" +
                "‚Ä¢ Delete ALL documents in playoffSeries\n" +
                "‚Ä¢ Delete ALL documents in playoffMatches\n" +
                "‚Ä¢ Create fresh Round of 32 matchups based on current standings\n\n" +
                "Are you sure you want to continue?"
            )
          )
            return;

          // Double confirm
          if (!confirm("Are you REALLY sure? This cannot be undone!")) return;

          try {
            resetBracketBtn.disabled = true;
            resetBracketBtn.textContent = "Resetting...";

            const statusDiv = document.getElementById(
              "playoffs-finalize-status"
            );
            if (statusDiv) statusDiv.textContent = "Deleting existing data...";

            // Step 1: Delete all playoffSeries documents
            console.log("üóëÔ∏è Step 1: Deleting playoffSeries...");
            const seriesRef = collection(db, "playoffSeries");
            let seriesSnap;
            try {
              seriesSnap = await getDocs(seriesRef);
              console.log(
                `  Found ${seriesSnap.docs.length} playoffSeries documents to delete`
              );
            } catch (readErr) {
              console.error("‚ùå Failed to READ playoffSeries:", readErr);
              throw new Error("Cannot read playoffSeries: " + readErr.message);
            }

            let deletedSeries = 0;
            for (const docSnap of seriesSnap.docs) {
              try {
                await deleteDoc(docSnap.ref);
                deletedSeries++;
              } catch (delErr) {
                console.error(
                  `‚ùå Failed to DELETE playoffSeries/${docSnap.id}:`,
                  delErr
                );
                throw new Error(
                  `Cannot delete playoffSeries/${docSnap.id}: ${delErr.message}`
                );
              }
            }
            console.log(`‚úÖ Deleted ${deletedSeries} playoffSeries documents`);

            // Step 2: Delete all playoffMatches documents
            console.log("üóëÔ∏è Step 2: Deleting playoffMatches...");
            const matchesRef = collection(db, "playoffMatches");
            let matchesSnap;
            try {
              matchesSnap = await getDocs(matchesRef);
              console.log(
                `  Found ${matchesSnap.docs.length} playoffMatches documents to delete`
              );
            } catch (readErr) {
              console.error("‚ùå Failed to READ playoffMatches:", readErr);
              throw new Error("Cannot read playoffMatches: " + readErr.message);
            }

            let deletedMatches = 0;
            for (const docSnap of matchesSnap.docs) {
              try {
                await deleteDoc(docSnap.ref);
                deletedMatches++;
              } catch (delErr) {
                console.error(
                  `‚ùå Failed to DELETE playoffMatches/${docSnap.id}:`,
                  delErr
                );
                throw new Error(
                  `Cannot delete playoffMatches/${docSnap.id}: ${delErr.message}`
                );
              }
            }
            console.log(
              `‚úÖ Deleted ${deletedMatches} playoffMatches documents`
            );

            if (statusDiv) statusDiv.textContent = "Creating fresh bracket...";

            // Step 3: Get current standings to seed the bracket
            console.log("üìä Step 3: Fetching standings...");
            const pointsRef = collection(db, "points");
            let pointsSnap;
            try {
              pointsSnap = await getDocs(pointsRef);
            } catch (readErr) {
              console.error("‚ùå Failed to READ points:", readErr);
              throw new Error("Cannot read points: " + readErr.message);
            }

            const players = [];
            pointsSnap.forEach((docSnap) => {
              const data = docSnap.data();
              // Log first few to see the data structure
              if (players.length < 5) {
                console.log(`  Player ${docSnap.id}:`, JSON.stringify(data));
              }
              players.push({
                alias: docSnap.id,
                displayName: data.displayName || docSnap.id,
                pts: data.pts || 0, // Using 'pts' field
              });
            });

            // Sort by points descending, then by displayName alphabetically for ties
            players.sort((a, b) => {
              if (b.pts !== a.pts) {
                return b.pts - a.pts; // Higher points first
              }
              // Same points - sort alphabetically by displayName
              return a.displayName
                .toLowerCase()
                .localeCompare(b.displayName.toLowerCase());
            });
            console.log(`üìã Found ${players.length} players total`);

            // Log the top 10 to verify sorting
            console.log("üèÜ Top 10 by points:");
            players.slice(0, 10).forEach((p, i) => {
              console.log(
                `  ${i + 1}. ${p.displayName} (${p.alias}): ${p.pts} pts`
              );
            });

            // Create seeds (top 32, fill with BYE if needed)
            const seeds = [];
            for (let i = 0; i < 32; i++) {
              if (players[i]) {
                seeds.push({
                  seed: i + 1,
                  alias: players[i].alias,
                  displayName: players[i].displayName,
                  isBye: false,
                });
              } else {
                seeds.push({
                  seed: i + 1,
                  alias: `BYE_${i + 1}`,
                  displayName: "BYE",
                  isBye: true,
                });
              }
            }

            console.log("üå± Seeds created:");
            seeds.slice(0, 10).forEach((s) => {
              console.log(
                `  #${s.seed}: ${s.displayName} (${s.alias})${
                  s.isBye ? " [BYE]" : ""
                }`
              );
            });

            // Standard bracket pairings for 32-team tournament
            // This ensures 1 plays 32, 2 plays 31, etc. in proper bracket order
            const bracketPairs = [
              [1, 32], // Match 0
              [16, 17], // Match 1
              [8, 25], // Match 2
              [9, 24], // Match 3
              [4, 29], // Match 4
              [13, 20], // Match 5
              [5, 28], // Match 6
              [12, 21], // Match 7
              [2, 31], // Match 8
              [15, 18], // Match 9
              [7, 26], // Match 10
              [10, 23], // Match 11
              [3, 30], // Match 12
              [14, 19], // Match 13
              [6, 27], // Match 14
              [11, 22], // Match 15
            ];

            // Create seed lookup map
            const seedMap = {};
            seeds.forEach((s) => {
              seedMap[s.seed] = s;
            });

            // Step 4: Create Round 1 (Round of 32) matchups
            console.log("üèÄ Creating Round of 32 matchups...");
            let createdMatches = 0;

            for (
              let matchIndex = 0;
              matchIndex < bracketPairs.length;
              matchIndex++
            ) {
              const [seed1, seed2] = bracketPairs[matchIndex];
              const player1 = seedMap[seed1];
              const player2 = seedMap[seed2];

              const matchData = {
                round: 1,
                matchIndex: matchIndex,
                aliases: [player1.alias, player2.alias],
                seeds: [seed1, seed2],
                displayNames: [player1.displayName, player2.displayName],
                status:
                  player1.isBye || player2.isBye ? "completed" : "pending",
                winnerAlias: null,
                createdAt: serverTimestamp(),
              };

              // If one player is a BYE, auto-advance the other
              if (player1.isBye && !player2.isBye) {
                matchData.winnerAlias = player2.alias;
                matchData.status = "completed";
              } else if (player2.isBye && !player1.isBye) {
                matchData.winnerAlias = player1.alias;
                matchData.status = "completed";
              }

              await addDoc(seriesRef, matchData);
              createdMatches++;
              console.log(
                `  ‚úÖ Match ${matchIndex}: #${seed1} ${player1.displayName} vs #${seed2} ${player2.displayName}`
              );
            }

            console.log(`üéâ Created ${createdMatches} Round of 32 matchups!`);

            // Step 5: Auto-advance BYE winners to Round 2
            if (statusDiv) statusDiv.textContent = "Processing BYE advances...";

            // Re-fetch the series to get the document IDs
            const newSeriesSnap = await getDocs(seriesRef);
            for (const docSnap of newSeriesSnap.docs) {
              const data = docSnap.data();
              if (data.status === "completed" && data.winnerAlias) {
                console.log(
                  `üöÄ Auto-advancing BYE winner: ${data.winnerAlias}`
                );
                await advanceWinnerToNextRound(db, docSnap, {
                  winnerAlias: data.winnerAlias,
                  winnerDisplayName: data.displayNames
                    ? data.aliases[0] === data.winnerAlias
                      ? data.displayNames[0]
                      : data.displayNames[1]
                    : data.winnerAlias,
                });
              }
            }

            if (statusDiv) {
              statusDiv.textContent = `‚úÖ Bracket reset complete! Created ${createdMatches} Round of 32 matchups.`;
            }

            alert(
              `Bracket reset complete!\n\n` +
                `‚Ä¢ Deleted ${deletedSeries} old series\n` +
                `‚Ä¢ Deleted ${deletedMatches} old matches\n` +
                `‚Ä¢ Created ${createdMatches} Round of 32 matchups\n\n` +
                `BYE winners have been auto-advanced to Round 2.`
            );

            // Refresh the admin table and bracket
            loadPlayoffMatches();
            startBracketListener();
          } catch (err) {
            console.error("Error resetting bracket:", err);
            alert("Error resetting bracket: " + err.message);
          } finally {
            resetBracketBtn.disabled = false;
            resetBracketBtn.textContent = "üîÑ Reset & Initialize Bracket";
          }
        });
      }

      // ============================================================================
      // ADMIN: Season Management Controls
      // ============================================================================

      const endPlayoffsBtn = document.getElementById("end-playoffs-btn");
      const archiveSeasonBtn = document.getElementById("archive-season-btn");
      const seasonNumberInput = document.getElementById("season-number-input");
      const seasonManagementStatus = document.getElementById(
        "season-management-status"
      );

      // End Playoffs - Sets playoffs to "ended" state, shows projected bracket
      if (endPlayoffsBtn) {
        endPlayoffsBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "Are you sure you want to end the playoffs?\n\nThis will close playoffs and show a projected bracket based on current standings."
            )
          ) {
            return;
          }

          try {
            endPlayoffsBtn.disabled = true;
            endPlayoffsBtn.textContent = "Ending...";
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = "Ending playoffs...";

            // Set playoffsFinalized to "ended" in config
            const configRef = doc(db, "config", "playoffs");
            await setDoc(
              configRef,
              {
                finalized: false,
                ended: true,
                endedAt: serverTimestamp(),
              },
              { merge: true }
            );

            if (seasonManagementStatus)
              seasonManagementStatus.textContent =
                "Playoffs ended successfully!";
            alert(
              "Playoffs have been ended. The bracket will now show projected matchups based on current standings."
            );
          } catch (err) {
            console.error("Error ending playoffs:", err);
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = "Error: " + err.message;
            alert("Error ending playoffs: " + err.message);
          } finally {
            endPlayoffsBtn.disabled = false;
            endPlayoffsBtn.textContent = "üèÅ End Playoffs";
          }
        });
      }

      // Archive & Reset Season - Archives points and H2H records, then clears them
      if (archiveSeasonBtn) {
        archiveSeasonBtn.addEventListener("click", async () => {
          const seasonNum = seasonNumberInput
            ? parseInt(seasonNumberInput.value) || 1
            : 1;

          if (
            !confirm(
              `‚ö†Ô∏è ARCHIVE SEASON ${seasonNum}\n\n` +
                `This will:\n` +
                `‚Ä¢ Save current points to 'archivedPoints/season${seasonNum}'\n` +
                `‚Ä¢ Save current H2H records to 'archivedH2H/season${seasonNum}'\n` +
                `‚Ä¢ Clear all current points (Season Standings)\n` +
                `‚Ä¢ Clear all current H2H records\n\n` +
                `Are you sure?`
            )
          ) {
            return;
          }

          if (!confirm("This CANNOT be undone. Are you REALLY sure?")) {
            return;
          }

          let currentStep = "";

          try {
            archiveSeasonBtn.disabled = true;
            archiveSeasonBtn.textContent = "Archiving...";
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = "Archiving season data...";

            // Step 1: Read points
            currentStep = "Step 1: Reading points";
            console.log("üì¶ " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            const pointsRef = collection(db, "points");
            const pointsSnap = await getDocs(pointsRef);

            const archivedPoints = {};
            pointsSnap.forEach((docSnap) => {
              archivedPoints[docSnap.id] = docSnap.data();
            });
            console.log(
              `‚úÖ Read ${Object.keys(archivedPoints).length} points records`
            );

            // Step 2: Save archived points
            currentStep =
              "Step 2: Saving archived points to archivedPoints/season" +
              seasonNum;
            console.log("üì¶ " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            const archivePointsRef = doc(
              db,
              "archivedPoints",
              "season" + seasonNum
            );
            await setDoc(archivePointsRef, {
              season: seasonNum,
              archivedAt: serverTimestamp(),
              data: archivedPoints,
            });
            console.log(`‚úÖ Archived points saved`);

            // Step 3: Read H2H records
            currentStep = "Step 3: Reading H2H records";
            console.log("üì¶ " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            const h2hRef = collection(db, "headtoheadRecords");
            const h2hSnap = await getDocs(h2hRef);

            const archivedH2H = {};
            h2hSnap.forEach((docSnap) => {
              archivedH2H[docSnap.id] = docSnap.data();
            });
            console.log(
              `‚úÖ Read ${Object.keys(archivedH2H).length} H2H records`
            );

            // Step 4: Save archived H2H
            currentStep =
              "Step 4: Saving archived H2H to archivedH2H/season" + seasonNum;
            console.log("üì¶ " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            const archiveH2HRef = doc(db, "archivedH2H", "season" + seasonNum);
            await setDoc(archiveH2HRef, {
              season: seasonNum,
              archivedAt: serverTimestamp(),
              data: archivedH2H,
            });
            console.log(`‚úÖ Archived H2H saved`);

            // Step 5: Clear current points
            currentStep = "Step 5: Clearing points collection";
            console.log("üóëÔ∏è " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            for (const docSnap of pointsSnap.docs) {
              await deleteDoc(docSnap.ref);
            }
            console.log(`‚úÖ Cleared ${pointsSnap.docs.length} points records`);

            // Step 6: Clear current H2H records
            currentStep = "Step 6: Clearing H2H records";
            console.log("üóëÔ∏è " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            for (const docSnap of h2hSnap.docs) {
              await deleteDoc(docSnap.ref);
            }
            console.log(`‚úÖ Cleared ${h2hSnap.docs.length} H2H records`);

            // Step 7: Reset playoffs config
            currentStep = "Step 7: Resetting playoffs config";
            console.log("üîÑ " + currentStep + "...");
            if (seasonManagementStatus)
              seasonManagementStatus.textContent = currentStep + "...";
            const configRef = doc(db, "config", "playoffs");
            await setDoc(configRef, {
              finalized: false,
              ended: false,
            });
            console.log(`‚úÖ Playoffs config reset`);

            if (seasonManagementStatus) {
              seasonManagementStatus.textContent = `Season ${seasonNum} archived successfully! Data has been saved and cleared.`;
            }

            alert(
              `Season ${seasonNum} archived successfully!\n\n` +
                `‚Ä¢ Archived ${
                  Object.keys(archivedPoints).length
                } points records\n` +
                `‚Ä¢ Archived ${Object.keys(archivedH2H).length} H2H records\n` +
                `‚Ä¢ Cleared all current standings\n\n` +
                `You can start the new season now!`
            );
          } catch (err) {
            console.error("Error at " + currentStep + ":", err);
            if (seasonManagementStatus)
              seasonManagementStatus.textContent =
                "Error at " + currentStep + ": " + err.message;
            alert("Error at " + currentStep + ":\n\n" + err.message);
          } finally {
            archiveSeasonBtn.disabled = false;
            archiveSeasonBtn.textContent = "üì¶ Archive & Reset Season";
          }
        });
      }

      /**
       * Try to pair this user with a waiting opponent.
       * If someone is waiting, create match doc and mark both as matched.
       * If not, you just stay waiting until someone else joins.
       */
      async function tryHeadToHeadMatchmaking(db, myQueueRef, myData) {
        const queueRef = collection(db, "headtoheadQueue");
        const myCategory = myData.category || "random";

        // cutoff: 10 minutes ago
        const cutoff = Timestamp.fromMillis(Date.now() - 10 * 60 * 1000);

        const q = query(
          queueRef,
          where("status", "==", "waiting"),
          orderBy("createdAt", "asc"),
          limit(50) // Increased to find matches across categories
        );

        const snap = await getDocs(q);

        let opponentDoc = null;
        let matchCategory = myCategory;

        for (const docSnap of snap.docs) {
          const data = docSnap.data();
          if (!data) continue;

          const createdAt =
            data.createdAt && data.createdAt.toMillis
              ? data.createdAt.toMillis()
              : null;

          // If older than cutoff, delete it and skip
          if (createdAt && createdAt < cutoff.toMillis()) {
            try {
              await deleteDoc(docSnap.ref);
            } catch (e) {
              console.error("Error deleting stale queue entry", e);
            }
            continue;
          }

          // skip myself and any same-client entries for safety
          if (
            docSnap.id === myQueueRef.id ||
            !data.clientId ||
            data.clientId === myData.clientId
          ) {
            continue;
          }

          const oppCategory = data.category || "random";

          // Category matching logic:
          // - Random matches with anyone
          // - Specific category only matches with same category OR random
          if (
            myCategory === "random" ||
            oppCategory === "random" ||
            myCategory === oppCategory
          ) {
            opponentDoc = docSnap;

            // Determine the actual match category
            if (myCategory === "random" && oppCategory === "random") {
              // Both random: pick a random category for the quiz
              const categoryKeys = [
                "geography",
                "history",
                "science",
                "sports",
                "entertainment",
                "music",
                "literature",
                "misc",
              ];
              matchCategory =
                categoryKeys[Math.floor(Math.random() * categoryKeys.length)];
            } else if (myCategory === "random") {
              matchCategory = oppCategory;
            } else {
              matchCategory = myCategory;
            }
            break;
          }
        }

        if (!opponentDoc) {
          // nobody else waiting yet (in compatible category)
          return;
        }

        const oppData = opponentDoc.data();

        // Create match and update both queue docs in a batch
        const batch = writeBatch(db);
        const matchesRef = collection(db, "headtoheadMatches");
        const matchRef = doc(matchesRef);

        // Get quiz from the matched category
        const quizUrl = await getRandomQuizUrlByCategory(db, matchCategory);

        batch.set(matchRef, {
          quizUrl,
          category: matchCategory, // NEW: store category in match
          status: "active",
          createdAt: serverTimestamp(),
          playerA: {
            clientId: myData.clientId,
            displayName: myData.displayName,
            alias: myData.alias,
          },
          playerB: {
            clientId: oppData.clientId,
            displayName: oppData.displayName,
            alias: oppData.alias,
          },
          scores: {
            playerA: null,
            playerB: null,
          },
          winnerAlias: null,
          loserAlias: null,
          tie: false,
          resolvedAt: null,
          ready: {
            playerA: false,
            playerB: false,
          },
        });

        batch.update(myQueueRef, {
          status: "matched",
          matchId: matchRef.id,
        });

        batch.update(opponentDoc.ref, {
          status: "matched",
          matchId: matchRef.id,
        });

        await batch.commit();
      }

      // Get a random quiz URL filtered by category
      async function getRandomQuizUrlByCategory(db, category) {
        // First try wheelQuizzes collection (which has categories)
        const wheelQuizzesRef = collection(db, "wheelQuizzes");
        const q = query(wheelQuizzesRef, where("category", "==", category));
        const snap = await getDocs(q);

        const urls = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (d && d.url) urls.push(d.url);
        });

        // If we found quizzes in the category, use one
        if (urls.length > 0) {
          // Avoid recent repeats
          let choice = null;
          for (let tries = 0; tries < 5; tries++) {
            const idx = Math.floor(Math.random() * urls.length);
            const candidate = urls[idx];
            if (!h2hRecentQuizUrls.includes(candidate)) {
              choice = candidate;
              break;
            }
          }
          if (!choice) {
            choice = urls[Math.floor(Math.random() * urls.length)];
          }

          h2hRecentQuizUrls.push(choice);
          if (h2hRecentQuizUrls.length > 10) {
            h2hRecentQuizUrls.shift();
          }

          return choice;
        }

        // Fallback to old quizzes collection (no category filter)
        return getRandomQuizUrl(db);
      }

      function renderHeadToHeadResult(match, youData, sideKey) {
        const scores = match.scores || {};
        const myScore = scores[sideKey];
        const oppScore = scores[sideKey === "playerA" ? "playerB" : "playerA"];

        if (!myScore || !oppScore) return; // just in case

        let summary;
        if (match.tie) {
          summary = "This match ended in a tie.";
        } else if (match.winnerAlias === youData.alias) {
          summary = "You won this match!";
        } else if (match.loserAlias === youData.alias) {
          summary = "You lost this match.";
        } else {
          summary = "Match completed.";
        }

        h2hResultSummary.textContent = summary;

        const detailLines = [];
        detailLines.push(
          `Your score: ${myScore.rawScore} (${Math.round(
            myScore.pct * 100
          )}%), time left: ${formatSecondsAsMMSS(myScore.timeLeftSeconds)}`
        );
        detailLines.push(
          `Opponent score: ${oppScore.rawScore} (${Math.round(
            oppScore.pct * 100
          )}%), time left: ${formatSecondsAsMMSS(oppScore.timeLeftSeconds)}`
        );

        h2hResultDetail.innerHTML = "";
        detailLines.forEach((t) => {
          const li = document.createElement("li");
          li.textContent = t;
          h2hResultDetail.appendChild(li);
        });

        h2hResultCard.classList.remove("d-none");
      }

      /**
       * Listen for changes on this user's queue doc.
       * When status becomes 'matched', load the match and show UI.
       */
      function listenForHeadToHeadMatch(db, queueRef, youData) {
        if (h2hQueueUnsub) {
          h2hQueueUnsub();
          h2hQueueUnsub = null;
        }
        h2hQueueUnsub = onSnapshot(queueRef, async (snap) => {
          if (!snap.exists()) {
            setH2HStatus("Your matchmaking request was removed.");
            return;
          }
          const data = snap.data();
          if (data.status === "waiting") {
            setH2HStatus("Waiting for an opponent...");
            return;
          }
          if (data.status === "matched" && data.matchId) {
            if (h2hCancelBtn) h2hCancelBtn.classList.add("d-none");
            clearHeadToHeadQueueTimers();
            setH2HStatus("Match found!");
            const matchRef = doc(db, "headtoheadMatches", data.matchId);
            h2hCurrentMatchRef = matchRef;
            const matchSnap = await getDoc(matchRef);
            if (!matchSnap.exists()) {
              setH2HStatus("Match could not be loaded.");
              return;
            }
            const match = matchSnap.data();
            let opp, sideKey;
            if (match.playerA.clientId === youData.clientId) {
              opp = match.playerB;
              sideKey = "playerA";
            } else {
              opp = match.playerA;
              sideKey = "playerB";
            }
            h2hYouData = youData;
            showH2HMatch(match, youData, opp, sideKey);

            // Also listen to the match document itself for score/result updates
            onSnapshot(matchRef, (mSnap) => {
              if (!mSnap.exists()) return;
              const mData = mSnap.data();

              const scores = mData.scores || {};
              const mySide = sideKey;
              const oppSide = mySide === "playerA" ? "playerB" : "playerA";

              // Show the match & score form once per match
              if (!h2hMatchShownOnce) {
                h2hMatchShownOnce = true;
                showH2HMatch(mData, youData, opp, mySide);
                clearHeadToHeadQueueTimers();
                setH2HStatus(
                  "Match found! Play the quiz and submit your score."
                );
              }

              const myScore = scores[mySide];
              const oppScore = scores[oppSide];

              // Status text for my score
              if (myScore && !mData.winnerAlias && !mData.tie) {
                h2hScoreStatus.textContent =
                  "Score submitted. Waiting for opponent...";
              }

              // When resolved, show final result
              if (
                mData.status === "completed" ||
                mData.winnerAlias ||
                mData.tie
              ) {
                renderHeadToHeadResult(mData, youData, mySide);
              }
            });
          }
        });
      }

      if (h2hScoreForm) {
        h2hScoreForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (!h2hCurrentMatchRef || !h2hCurrentSide || !h2hYouData) {
            h2hScoreStatus.textContent = "No active match.";
            return;
          }
          const parsed = parseScoreString(h2hScoreInput.value);
          if (!parsed) {
            h2hScoreStatus.textContent =
              "Invalid score format. Use num/den, e.g., 10/15.";
            return;
          }
          const seconds = parseTimeString(h2hTimeInput.value);
          if (seconds === null) {
            h2hScoreStatus.textContent =
              "Invalid time. Use mm:ss (e.g., 01:23).";
            return;
          }

          const scoreObj = {
            ...parsed,
            timeLeftSeconds: seconds,
            submittedAt: serverTimestamp(),
          };

          try {
            const fieldPath = `scores.${h2hCurrentSide}`;
            h2hScoreStatus.textContent = "Submitting...";
            await updateDoc(h2hCurrentMatchRef, {
              [fieldPath]: scoreObj,
            });
            h2hScoreStatus.textContent =
              "Score submitted. Waiting for opponent...";
            h2hScoreInput.disabled = true;
            h2hTimeInput.disabled = true;
            document.getElementById("h2h-score-submit-btn").disabled = true;

            // Attempt to resolve match (this is safe via transaction below)
            await resolveHeadToHeadMatch(db, h2hCurrentMatchRef);
          } catch (err) {
            console.error("Error submitting score", err);
            h2hScoreStatus.textContent = "Error submitting score.";
          }
        });
      }

      // Handle form submission
      if (h2hSigninBtn) {
        h2hSigninBtn.addEventListener("click", () => {
          if (window.showAuthModal) {
            window.showAuthModal("signin");
          }
        });
      }

      // Function to update H2H UI based on auth state
      function updateH2HAuthUI(user, profile) {
        if (user && profile) {
          // User is logged in with profile
          if (h2hUserInfo) h2hUserInfo.classList.remove("d-none");
          if (h2hSigninPrompt) h2hSigninPrompt.classList.add("d-none");
          if (h2hUserDisplay) h2hUserDisplay.textContent = profile.displayName;
          if (h2hUserAlias) h2hUserAlias.textContent = profile.alias;
        } else {
          // User not logged in
          if (h2hUserInfo) h2hUserInfo.classList.add("d-none");
          if (h2hSigninPrompt) h2hSigninPrompt.classList.remove("d-none");
        }
      }

      // Make it globally accessible for auth section
      window.updateH2HAuthUI = updateH2HAuthUI;

      if (h2hFindBtn) {
        h2hFindBtn.addEventListener("click", async () => {
          // Check if user is logged in
          if (!window.currentUser || !window.currentProfile) {
            setH2HStatus("Please sign in to play Head to Head.");
            if (window.showAuthModal) {
              window.showAuthModal("signin");
            }
            return;
          }

          const displayName = window.currentProfile.displayName;
          const alias = window.currentProfile.alias;
          const clientId = window.currentUser.uid; // Use Firebase UID as client ID

          // Get selected category
          const category = h2hSelectedCategoryInput
            ? h2hSelectedCategoryInput.value
            : "random";
          h2hSelectedCategory = category;
          const categoryInfo = h2hCategories[category] || h2hCategories.random;

          const youData = { displayName, alias, clientId, category };

          setH2HStatus(
            "Joining " +
              categoryInfo.icon +
              " " +
              categoryInfo.name +
              " queue..."
          );
          h2hMatchCard.classList.add("d-none");
          h2hScoreCard.classList.add("d-none");
          h2hResultCard.classList.add("d-none");

          // remove any old "waiting" entries for this client
          await cleanupOldQueueEntries(db, clientId);

          const queueRef = collection(db, "headtoheadQueue");

          // create or replace this client's queue entry with category
          const myDocRef = await addDoc(queueRef, {
            clientId,
            displayName,
            alias,
            category, // NEW: include category in queue
            status: "waiting",
            matchId: null,
            createdAt: serverTimestamp(),
          });

          h2hQueueDocRef = myDocRef;
          h2hMatchShownOnce = false;

          if (h2hCancelBtn) h2hCancelBtn.classList.remove("d-none");
          if (h2hFindBtn) h2hFindBtn.disabled = true;

          // START the queue timers here (with retry logic):
          startHeadToHeadQueueTimers(db, myDocRef, youData);

          // start listening and try to match...
          listenForHeadToHeadMatch(db, myDocRef, youData);
          try {
            await tryHeadToHeadMatchmaking(db, myDocRef, youData);
            // do NOT override status in catch; timers are updating it
          } catch (err) {
            console.error("Error during matchmaking", err);
          }
        });
      }

      async function resolveHeadToHeadMatch(db, matchRef) {
        // 1) Read the match once
        const matchSnap = await getDoc(matchRef);
        if (!matchSnap.exists()) return;

        const match = matchSnap.data();
        const scores = match.scores || {};
        const sA = scores.playerA;
        const sB = scores.playerB;
        const matchCategory = match.category || "misc"; // Get match category

        // Need both scores to resolve
        if (!sA || !sB) return;

        // Already resolved? Do nothing
        if (match.status === "completed" || match.winnerAlias || match.tie) {
          return;
        }

        const pA = match.playerA;
        const pB = match.playerB;

        // 2) Decide winner / loser / tie
        const pctA = sA.pct || 0;
        const pctB = sB.pct || 0;
        const timeA = sA.timeLeftSeconds || 0;
        const timeB = sB.timeLeftSeconds || 0;

        let winnerAlias = null;
        let loserAlias = null;
        let tie = false;

        if (pctA > pctB) {
          winnerAlias = pA.alias;
          loserAlias = pB.alias;
        } else if (pctB > pctA) {
          winnerAlias = pB.alias;
          loserAlias = pA.alias;
        } else {
          // same percent, use time left
          if (timeA > timeB) {
            winnerAlias = pA.alias;
            loserAlias = pB.alias;
          } else if (timeB > timeA) {
            winnerAlias = pB.alias;
            loserAlias = pA.alias;
          } else {
            tie = true;
          }
        }

        // 3) Load existing records for both players
        const recordsRef = collection(db, "headtoheadRecords");
        const refA = doc(recordsRef, pA.alias);
        const refB = doc(recordsRef, pB.alias);

        const [recASnap, recBSnap] = await Promise.all([
          getDoc(refA),
          getDoc(refB),
        ]);

        // Helper to initialize category stats
        function initCategoryStats() {
          return { wins: 0, losses: 0, ties: 0 };
        }

        let recA = recASnap.exists()
          ? recASnap.data()
          : {
              alias: pA.alias,
              displayName: pA.displayName,
              wins: 0,
              losses: 0,
              ties: 0,
              streakType: null, // "W" or "L"
              streakCount: 0,
              bestStreakType: null, // "W" or "L"
              bestStreakCount: 0,
              categoryStats: {}, // NEW: per-category stats
            };

        let recB = recBSnap.exists()
          ? recBSnap.data()
          : {
              alias: pB.alias,
              displayName: pB.displayName,
              wins: 0,
              losses: 0,
              ties: 0,
              streakType: null,
              streakCount: 0,
              bestStreakType: null,
              bestStreakCount: 0,
              categoryStats: {}, // NEW: per-category stats
            };

        // Ensure streak fields exist on old docs
        if (recA.streakType === undefined) recA.streakType = null;
        if (recA.streakCount === undefined) recA.streakCount = 0;
        if (recA.bestStreakType === undefined) recA.bestStreakType = null;
        if (recA.bestStreakCount === undefined) recA.bestStreakCount = 0;
        if (!recA.categoryStats) recA.categoryStats = {};

        if (recB.streakType === undefined) recB.streakType = null;
        if (recB.streakCount === undefined) recB.streakCount = 0;
        if (recB.bestStreakType === undefined) recB.bestStreakType = null;
        if (recB.bestStreakCount === undefined) recB.bestStreakCount = 0;
        if (!recB.categoryStats) recB.categoryStats = {};

        // Initialize category stats if needed
        if (!recA.categoryStats[matchCategory]) {
          recA.categoryStats[matchCategory] = initCategoryStats();
        }
        if (!recB.categoryStats[matchCategory]) {
          recB.categoryStats[matchCategory] = initCategoryStats();
        }

        // 4) Update their records in memory (overall AND category)
        if (tie) {
          recA.ties = (recA.ties || 0) + 1;
          recB.ties = (recB.ties || 0) + 1;
          recA.categoryStats[matchCategory].ties += 1;
          recB.categoryStats[matchCategory].ties += 1;
        } else {
          if (winnerAlias === pA.alias) {
            // A wins, B loses
            recA.wins = (recA.wins || 0) + 1;
            recB.losses = (recB.losses || 0) + 1;
            recA.categoryStats[matchCategory].wins += 1;
            recB.categoryStats[matchCategory].losses += 1;

            // A current streak (wins)
            if (recA.streakType === "W") {
              recA.streakCount = (recA.streakCount || 0) + 1;
            } else {
              recA.streakType = "W";
              recA.streakCount = 1;
            }

            // B current streak (losses)
            if (recB.streakType === "L") {
              recB.streakCount = (recB.streakCount || 0) + 1;
            } else {
              recB.streakType = "L";
              recB.streakCount = 1;
            }

            // BEST streak: only track BEST WIN streaks
            if (
              recA.streakType === "W" &&
              recA.streakCount > (recA.bestStreakCount || 0)
            ) {
              recA.bestStreakType = "W";
              recA.bestStreakCount = recA.streakCount;
            }
            // Do NOT update best streak for B on losses
          } else {
            // B wins, A loses
            recB.wins = (recB.wins || 0) + 1;
            recA.losses = (recA.losses || 0) + 1;
            recB.categoryStats[matchCategory].wins += 1;
            recA.categoryStats[matchCategory].losses += 1;

            if (recB.streakType === "W") {
              recB.streakCount = (recB.streakCount || 0) + 1;
            } else {
              recB.streakType = "W";
              recB.streakCount = 1;
            }

            if (recA.streakType === "L") {
              recA.streakCount = (recA.streakCount || 0) + 1;
            } else {
              recA.streakType = "L";
              recA.streakCount = 1;
            }

            if (
              recB.streakType === "W" &&
              recB.streakCount > (recB.bestStreakCount || 0)
            ) {
              recB.bestStreakType = "W";
              recB.bestStreakCount = recB.streakCount;
            }
            // Do NOT update best streak for A on losses
          }
        }

        // 5) Write everything in one batch
        const batch = writeBatch(db);

        const matchUpdate = {
          status: "completed",
          resolvedAt: serverTimestamp(),
          tie,
        };
        if (!tie) {
          matchUpdate.winnerAlias = winnerAlias;
          matchUpdate.loserAlias = loserAlias;
        }

        batch.update(matchRef, matchUpdate);
        batch.set(refA, recA, { merge: true });
        batch.set(refB, recB, { merge: true });

        await batch.commit();
      }

      function renderHeadToHeadStandings(rows) {
        if (!h2hStandingsBody) return;
        h2hStandingsBody.innerHTML = "";

        // compute win pct & games
        // compute games and win% (still useful to show)
        rows.forEach((r) => {
          const w = r.wins || 0;
          const l = r.losses || 0;
          const t = r.ties || 0; // kept for compatibility, but not used in % now

          // Win% is based ONLY on wins + losses
          const wlGames = w + l;
          r.games = wlGames; // use this for the Win% denominator
          r.winPct = wlGames > 0 ? w / wlGames : 0;
        });

        // sort: more wins first, then higher win%, then fewer games, then alias
        rows.sort((a, b) => {
          if ((b.wins || 0) !== (a.wins || 0))
            return (b.wins || 0) - (a.wins || 0);
          if ((b.winPct || 0) !== (a.winPct || 0))
            return (b.winPct || 0) - (a.winPct || 0);
          if ((a.games || 0) !== (b.games || 0))
            return (a.games || 0) - (b.games || 0);
          return (a.alias || "").localeCompare(b.alias || "");
        });

        rows.forEach((r, idx) => {
          const tr = document.createElement("tr");
          const winPctStr =
            r.games > 0 ? (r.winPct * 100).toFixed(1) + "%" : "‚Äì";

          const streakType = r.streakType || null;
          const streakCount = r.streakCount || 0;
          const streakLabel =
            streakType && streakCount > 0 ? `${streakType}${streakCount}` : "‚Äì";

          const bestType = r.bestStreakType || null;
          const bestCount = r.bestStreakCount || 0;
          const bestLabel =
            bestType === "W" && bestCount > 0 ? `W${bestCount}` : "‚Äì";

          // Get champion badges
          const badges = window.getChampionBadges
            ? window.getChampionBadges(r.alias)
            : "";

          tr.innerHTML = `
    <td>${idx + 1}</td>
    <td>${r.displayName || ""}${badges}</td>
    <td>${r.alias || ""}</td>
    <td>${r.wins || 0}</td>
    <td>${r.losses || 0}</td>
    <td>${streakLabel}</td>
    <td>${bestLabel}</td>
    <td>${winPctStr}</td>
  `;
          h2hStandingsBody.appendChild(tr);
        });

        // Also render category-specific standings
        renderCategoryStandings(rows);
      }

      // Render category-specific standings
      function renderCategoryStandings(rows) {
        const categories = [
          "geography",
          "history",
          "science",
          "sports",
          "entertainment",
          "music",
          "literature",
          "misc",
        ];

        categories.forEach((category) => {
          const tbody = document.getElementById(
            `h2h-standings-body-${category}`
          );
          const emptyDiv = document.getElementById(`h2h-empty-${category}`);
          if (!tbody) return;

          tbody.innerHTML = "";

          // Extract category stats for each player
          const categoryRows = [];
          rows.forEach((r) => {
            const catStats = r.categoryStats && r.categoryStats[category];
            if (catStats && (catStats.wins > 0 || catStats.losses > 0)) {
              const w = catStats.wins || 0;
              const l = catStats.losses || 0;
              const games = w + l;
              categoryRows.push({
                displayName: r.displayName,
                alias: r.alias,
                wins: w,
                losses: l,
                games: games,
                winPct: games > 0 ? w / games : 0,
              });
            }
          });

          // Sort by wins, then win%, then alias
          categoryRows.sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            if (b.winPct !== a.winPct) return b.winPct - a.winPct;
            return (a.alias || "").localeCompare(b.alias || "");
          });

          if (categoryRows.length === 0) {
            if (emptyDiv) emptyDiv.classList.remove("d-none");
            return;
          }
          if (emptyDiv) emptyDiv.classList.add("d-none");

          categoryRows.forEach((r, idx) => {
            const tr = document.createElement("tr");
            const winPctStr =
              r.games > 0 ? (r.winPct * 100).toFixed(1) + "%" : "‚Äì";
            // Get champion badges
            const badges = window.getChampionBadges
              ? window.getChampionBadges(r.alias)
              : "";
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td>${r.displayName || ""}${badges}</td>
              <td>${r.alias || ""}</td>
              <td>${r.wins}</td>
              <td>${r.losses}</td>
              <td>${winPctStr}</td>
            `;
            tbody.appendChild(tr);
          });
        });
      }

      // Subscribe to records
      (function subscribeHeadToHeadStandings() {
        const ref = collection(db, "headtoheadRecords");
        onSnapshot(ref, (snap) => {
          const rows = [];
          snap.forEach((d) => {
            rows.push({ id: d.id, ...(d.data() || {}) });
          });
          renderHeadToHeadStandings(rows);
        });
      })();

      // ========== QUIZ WHEEL ==========
      (function () {
        // Fallback quiz data by category (used if Firestore is empty)
        const fallbackQuizzes = {
          geography: [
            {
              title: "Countries of the World",
              description: "Can you name all 197 countries?",
              url: "https://www.sporcle.com/games/g/world",
            },
            {
              title: "US States",
              description: "Name all 50 US states on the map.",
              url: "https://www.sporcle.com/games/g/states",
            },
          ],
          history: [
            {
              title: "US Presidents",
              description: "Name all 46 US Presidents.",
              url: "https://www.sporcle.com/games/g/presidents",
            },
          ],
          science: [
            {
              title: "Periodic Table",
              description: "Name all the chemical elements.",
              url: "https://www.sporcle.com/games/g/elements",
            },
          ],
          sports: [
            {
              title: "NFL Teams",
              description: "Name all 32 NFL teams.",
              url: "https://www.sporcle.com/games/g/nflteams",
            },
          ],
          entertainment: [
            {
              title: "Oscar Best Pictures",
              description: "Name all Best Picture winners.",
              url: "https://www.sporcle.com/games/g/bestpicture",
            },
          ],
          music: [
            {
              title: "Billboard #1 Hits",
              description: "Name songs that hit #1.",
              url: "https://www.sporcle.com/games/g/billboardone",
            },
          ],
          literature: [
            {
              title: "Shakespeare Plays",
              description: "Name all of Shakespeare's plays.",
              url: "https://www.sporcle.com/games/g/shakespeare",
            },
          ],
          misc: [
            {
              title: "Flags of the World",
              description: "Identify country flags.",
              url: "https://www.sporcle.com/games/g/worldflags",
            },
          ],
        };

        // This will be populated from Firestore
        let wheelQuizzes = {};

        // Categories in order - segment 0 starts at top of wheel and goes clockwise
        const wheelCategories = [
          { key: "geography", name: "Geography", icon: "üåç", color: "#f85149" },
          { key: "history", name: "History", icon: "üèõÔ∏è", color: "#d29922" },
          { key: "science", name: "Science", icon: "üî¨", color: "#3fb950" },
          { key: "sports", name: "Sports", icon: "‚öΩ", color: "#58a6ff" },
          {
            key: "entertainment",
            name: "Movies/TV",
            icon: "üé¨",
            color: "#a371f7",
          },
          { key: "music", name: "Music", icon: "üéµ", color: "#f778ba" },
          {
            key: "literature",
            name: "Literature",
            icon: "üìö",
            color: "#79c0ff",
          },
          { key: "misc", name: "Misc", icon: "‚ùì", color: "#ffa657" },
        ];

        const NUM_SEGMENTS = wheelCategories.length;
        const SEGMENT_ANGLE = 360 / NUM_SEGMENTS; // 45 degrees per segment

        let wheelCanvas, wheelCtx, wheelCenterX, wheelCenterY, wheelRadius;
        let wheelCurrentRotation = 0;
        let wheelIsSpinning = false;
        let lastSpinTimestamp = 0;
        let isAdmin = false;

        function lightenColor(color, percent) {
          const num = parseInt(color.replace("#", ""), 16);
          const amt = Math.round(2.55 * percent);
          const R = (num >> 16) + amt;
          const G = ((num >> 8) & 0x00ff) + amt;
          const B = (num & 0x0000ff) + amt;
          return (
            "#" +
            (
              0x1000000 +
              (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
              (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
              (B < 255 ? (B < 1 ? 0 : B) : 255)
            )
              .toString(16)
              .slice(1)
          );
        }

        function drawWheel() {
          if (!wheelCtx) return;

          const anglePerSegment = (2 * Math.PI) / NUM_SEGMENTS;

          wheelCtx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);

          wheelCategories.forEach((cat, i) => {
            // Start at -90 degrees (top) and go clockwise
            const startAngle = i * anglePerSegment - Math.PI / 2;
            const endAngle = startAngle + anglePerSegment;

            wheelCtx.beginPath();
            wheelCtx.moveTo(wheelCenterX, wheelCenterY);
            wheelCtx.arc(
              wheelCenterX,
              wheelCenterY,
              wheelRadius,
              startAngle,
              endAngle
            );
            wheelCtx.closePath();

            const gradient = wheelCtx.createRadialGradient(
              wheelCenterX,
              wheelCenterY,
              0,
              wheelCenterX,
              wheelCenterY,
              wheelRadius
            );
            gradient.addColorStop(0, lightenColor(cat.color, 20));
            gradient.addColorStop(1, cat.color);
            wheelCtx.fillStyle = gradient;
            wheelCtx.fill();

            wheelCtx.strokeStyle = "rgba(0,0,0,0.3)";
            wheelCtx.lineWidth = 2;
            wheelCtx.stroke();

            // Draw text - rotated to middle of segment
            wheelCtx.save();
            wheelCtx.translate(wheelCenterX, wheelCenterY);
            wheelCtx.rotate(startAngle + anglePerSegment / 2);
            wheelCtx.textAlign = "right";
            wheelCtx.fillStyle = "white";
            wheelCtx.shadowColor = "rgba(0,0,0,0.5)";
            wheelCtx.shadowBlur = 4;

            wheelCtx.font = "20px Arial";
            wheelCtx.fillText(cat.icon, wheelRadius - 20, 7);

            wheelCtx.font = "bold 10px Arial";
            wheelCtx.fillText(cat.name, wheelRadius - 45, 5);

            wheelCtx.restore();
          });

          // Inner circle shadow
          wheelCtx.beginPath();
          wheelCtx.arc(wheelCenterX, wheelCenterY, 35, 0, 2 * Math.PI);
          wheelCtx.fillStyle = "rgba(0,0,0,0.2)";
          wheelCtx.fill();
        }

        // Calculate which segment the pointer is pointing at given a rotation
        function getWinningSegment(totalRotation) {
          // Normalize rotation to 0-360
          let normalizedRotation = totalRotation % 360;
          if (normalizedRotation < 0) normalizedRotation += 360;

          // When the wheel rotates CLOCKWISE by X degrees, the segment that
          // ends up under the pointer (at top) is the one from position (360 - X).
          //
          // Formula: effectiveAngle = 360 - normalizedRotation
          // segmentIndex = floor(effectiveAngle / 45)
          //
          // Verified against actual spins:
          // - 152¬∞ rotation ‚Üí Movies/TV (4): (360-152)/45 = 4.6 ‚Üí 4 ‚úì
          // - 1¬∞ rotation ‚Üí Misc (7): (360-1)/45 = 7.97 ‚Üí 7 ‚úì
          // - 227¬∞ rotation ‚Üí Science (2): (360-227)/45 = 2.95 ‚Üí 2 ‚úì

          let effectiveAngle = 360 - normalizedRotation;
          if (effectiveAngle < 0) effectiveAngle += 360;

          const segmentIndex =
            Math.floor(effectiveAngle / SEGMENT_ANGLE) % NUM_SEGMENTS;

          console.log("getWinningSegment DEBUG:", {
            totalRotation: totalRotation,
            normalizedRotation: normalizedRotation,
            effectiveAngle: effectiveAngle,
            segmentIndex: segmentIndex,
            categoryName: wheelCategories[segmentIndex].name,
          });

          return segmentIndex;
        }

        // Debug helper - call from console: testWheelPosition(degrees)
        window.testWheelPosition = function (degrees) {
          if (wheelCanvas) {
            wheelCanvas.style.transform = `rotate(${degrees}deg)`;
            wheelCurrentRotation = degrees;
            const segment = getWinningSegment(degrees);
            console.log(
              `At ${degrees}¬∞: ${wheelCategories[segment].name} (${wheelCategories[segment].icon})`
            );
            return wheelCategories[segment].name;
          }
        };

        function initWheel() {
          wheelCanvas = document.getElementById("wheel-canvas");
          if (!wheelCanvas) return;

          wheelCtx = wheelCanvas.getContext("2d");
          wheelCenterX = wheelCanvas.width / 2;
          wheelCenterY = wheelCanvas.height / 2;
          wheelRadius = wheelCanvas.width / 2 - 5;

          drawWheel();

          // Set up spin button click handler
          const spinBtn = document.getElementById("spin-btn");
          if (spinBtn) {
            spinBtn.addEventListener("click", handleSpinClick);
          }

          // Listen for wheel spin updates from Firestore
          if (window.shared && window.shared.listenWheelSpin) {
            window.shared.listenWheelSpin(handleWheelSpinUpdate);
          }

          // Load quizzes from Firestore
          if (window.shared && window.shared.listenWheelQuizzes) {
            window.shared.listenWheelQuizzes(handleQuizzesUpdate);
          }
        }

        // Called when wheelQuizzes collection updates
        function handleQuizzesUpdate(snapshot) {
          // Reset wheelQuizzes
          wheelQuizzes = {};
          wheelCategories.forEach((cat) => {
            wheelQuizzes[cat.key] = [];
          });

          // Populate from Firestore
          snapshot.forEach((docSnap) => {
            const data = docSnap.data();
            if (data.category && wheelQuizzes[data.category]) {
              wheelQuizzes[data.category].push({
                title: data.title || "Untitled Quiz",
                description: data.description || "Play this quiz!",
                url: data.url || "#",
              });
            }
          });

          // Log quiz counts
          console.log("Wheel quizzes loaded from Firestore:");
          wheelCategories.forEach((cat) => {
            const count = wheelQuizzes[cat.key]?.length || 0;
            console.log(`  ${cat.icon} ${cat.name}: ${count} quizzes`);
          });
        }

        // Get quizzes for a category (with fallback)
        function getQuizzesForCategory(categoryKey) {
          // Check if we have quizzes loaded from Firestore
          if (
            wheelQuizzes[categoryKey] &&
            wheelQuizzes[categoryKey].length > 0
          ) {
            return wheelQuizzes[categoryKey];
          }
          // Fall back to hardcoded quizzes
          if (
            fallbackQuizzes[categoryKey] &&
            fallbackQuizzes[categoryKey].length > 0
          ) {
            console.log(`Using fallback quizzes for ${categoryKey}`);
            return fallbackQuizzes[categoryKey];
          }
          // Last resort fallback
          return [
            {
              title: "Random Quiz",
              description: "A surprise quiz!",
              url: "https://www.sporcle.com/games/category/geography",
            },
          ];
        }

        // Admin clicks spin - just save rotation to Firestore
        // The actual category/quiz determination happens AFTER the spin completes
        async function handleSpinClick() {
          if (wheelIsSpinning) return;

          const spinBtn = document.getElementById("spin-btn");
          spinBtn.disabled = true;
          spinBtn.textContent = "üé≤ Spinning...";
          updateSpinStatus("Starting spin...");

          // Calculate random spin parameters
          const spinDuration = 4500 + Math.random() * 1000; // 4.5-5.5 seconds
          const fullRotations = 5 + Math.floor(Math.random() * 3); // 5-7 full spins
          const randomExtraAngle = Math.random() * 360; // Random final position
          const targetRotation = fullRotations * 360 + randomExtraAngle;

          // Save ONLY the spin parameters to Firestore
          // Category and quiz will be determined AFTER spin completes
          try {
            await window.shared.setWheelSpin({
              targetRotation: targetRotation,
              spinDuration: spinDuration,
              phase: "spinning", // Indicates spin is in progress, no result yet
            });
          } catch (err) {
            console.error("Error saving wheel spin:", err);
            spinBtn.disabled = false;
            spinBtn.textContent = "üé≤ Spin the Wheel!";
            updateSpinStatus("Error starting spin");
          }
        }

        // Called when Firestore wheelSpin document updates
        function handleWheelSpinUpdate(snapshot) {
          if (!snapshot.exists()) {
            updateSpinStatus("Waiting for admin to spin the wheel...");
            return;
          }

          const data = snapshot.data();

          // Check if this is a new spin we need to animate
          if (
            data.timestamp &&
            data.timestamp > lastSpinTimestamp &&
            data.phase === "spinning"
          ) {
            lastSpinTimestamp = data.timestamp;
            animateWheelSpin(data);
          }
          // Or if it's a completed spin with results (page load case)
          else if (data.phase === "complete" && data.quiz) {
            // Set wheel to final position without animation
            if (data.finalRotation) {
              wheelCurrentRotation = data.finalRotation;
              if (wheelCanvas) {
                wheelCanvas.style.transform = `rotate(${wheelCurrentRotation}deg)`;
              }
            }
            displayQuizResult(data);
          }
        }

        function animateWheelSpin(data) {
          if (wheelIsSpinning) return;
          wheelIsSpinning = true;

          const spinBtn = document.getElementById("spin-btn");
          if (spinBtn) {
            spinBtn.disabled = true;
            spinBtn.textContent = "üé≤ Spinning...";
          }
          updateSpinStatus("Spinning...");

          // Hide any previous result during spin
          hideQuizResult();

          const startRotation = wheelCurrentRotation;
          const rotationAmount = data.targetRotation;
          const finalRotation = startRotation + rotationAmount;
          const spinDuration = data.spinDuration || 4500;
          const startTime = performance.now();

          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / spinDuration, 1);

            // Cubic ease-out for realistic deceleration
            const easeOut = 1 - Math.pow(1 - progress, 3);

            wheelCurrentRotation = startRotation + rotationAmount * easeOut;
            if (wheelCanvas) {
              wheelCanvas.style.transform = `rotate(${wheelCurrentRotation}deg)`;
            }

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Animation complete!
              wheelCurrentRotation = finalRotation;
              if (wheelCanvas) {
                wheelCanvas.style.transform = `rotate(${wheelCurrentRotation}deg)`;
              }

              // Wait a moment for the wheel to visually settle
              setTimeout(() => {
                onSpinComplete(finalRotation, data.timestamp);
              }, 500);
            }
          }

          requestAnimationFrame(animate);
        }

        // Called after wheel animation completes - determine winner and show result
        async function onSpinComplete(finalRotation, spinTimestamp) {
          wheelIsSpinning = false;

          const spinBtn = document.getElementById("spin-btn");
          if (spinBtn) {
            spinBtn.disabled = false;
            spinBtn.textContent = "üé≤ Spin Again!";
          }

          // Calculate which segment we landed on
          const winningIndex = getWinningSegment(finalRotation);
          const winningCategory = wheelCategories[winningIndex];

          console.log(
            "Spin complete! Final rotation:",
            finalRotation,
            "Winning index:",
            winningIndex,
            "Category:",
            winningCategory.name
          );

          // Pick a random quiz from that category (uses Firestore quizzes with fallback)
          const categoryQuizzes = getQuizzesForCategory(winningCategory.key);
          const randomQuiz =
            categoryQuizzes[Math.floor(Math.random() * categoryQuizzes.length)];

          // Update Firestore with the complete result
          // Only do this if we're admin (the one who initiated the spin)
          if (isAdmin) {
            try {
              await window.shared.setWheelSpin({
                targetRotation:
                  finalRotation - (wheelCurrentRotation - finalRotation), // Keep original target
                finalRotation: finalRotation,
                spinDuration: 4500,
                phase: "complete",
                categoryKey: winningCategory.key,
                categoryName: winningCategory.name,
                categoryIcon: winningCategory.icon,
                quiz: randomQuiz,
                timestamp: spinTimestamp, // Keep the same timestamp
              });

              // Also update the quiz link for compatibility
              await window.shared.setQuizLink(randomQuiz.url);
            } catch (err) {
              console.error("Error saving spin result:", err);
            }
          }

          // Display the result locally
          displayQuizResult({
            categoryKey: winningCategory.key,
            categoryName: winningCategory.name,
            categoryIcon: winningCategory.icon,
            quiz: randomQuiz,
          });

          // Confetti celebration!
          createConfetti();
        }

        function hideQuizResult() {
          const card = document.getElementById("quiz-result-card");
          const header = document.getElementById("quiz-result-header");
          const title = document.getElementById("quiz-result-title");
          const quizName = document.getElementById("quiz-name");
          const quizDesc = document.getElementById("quiz-description");
          const quizLink = document.getElementById("quiz-link-display");
          const quizUrl = document.getElementById("quiz-url-display");

          if (card) card.classList.remove("has-quiz");
          if (header) {
            header.className = "quiz-result-header no-quiz";
          }
          if (title) {
            title.innerHTML = "<span>üé≤</span><span>Spinning...</span>";
          }
          if (quizName) quizName.textContent = "Determining category...";
          if (quizDesc) quizDesc.textContent = "Watch the wheel!";
          if (quizLink) quizLink.classList.add("d-none");
          if (quizUrl) quizUrl.classList.add("d-none");
        }

        function displayQuizResult(data) {
          const card = document.getElementById("quiz-result-card");
          const header = document.getElementById("quiz-result-header");
          const title = document.getElementById("quiz-result-title");
          const quizName = document.getElementById("quiz-name");
          const quizDesc = document.getElementById("quiz-description");
          const quizLink = document.getElementById("quiz-link-display");
          const quizUrl = document.getElementById("quiz-url-display");

          if (card) card.classList.add("has-quiz");

          if (header) {
            header.classList.remove("no-quiz");
            header.className =
              "quiz-result-header wheel-cat-" + data.categoryKey;
          }

          if (title) {
            title.innerHTML =
              "<span>" +
              (data.categoryIcon || "üéØ") +
              "</span><span>" +
              (data.categoryName || "Quiz") +
              "</span>";
          }

          if (data.quiz) {
            if (quizName) quizName.textContent = data.quiz.title;
            if (quizDesc) quizDesc.textContent = data.quiz.description;
            if (quizLink) {
              quizLink.href = data.quiz.url;
              quizLink.textContent = "‚ñ∂ Play This Quiz";
              quizLink.classList.remove("d-none");
            }
            if (quizUrl) {
              quizUrl.textContent = data.quiz.url;
              quizUrl.classList.remove("d-none");
            }
          }

          updateSpinStatus("");
        }

        function updateSpinStatus(message) {
          const status = document.getElementById("spin-status");
          if (status) {
            status.textContent = message;
          }
        }

        function createConfetti() {
          const container = document.getElementById("wheel-confetti");
          if (!container) return;

          container.innerHTML = "";
          const colors = wheelCategories.map((c) => c.color);

          for (let i = 0; i < 100; i++) {
            const piece = document.createElement("div");
            piece.className = "wheel-confetti-piece";
            piece.style.left = Math.random() * 100 + "%";
            piece.style.background =
              colors[Math.floor(Math.random() * colors.length)];
            piece.style.animationDelay = Math.random() * 0.5 + "s";
            piece.style.animationDuration = 2 + Math.random() * 2 + "s";
            piece.style.width = 5 + Math.random() * 10 + "px";
            piece.style.height = 5 + Math.random() * 10 + "px";

            if (Math.random() > 0.5) {
              piece.style.borderRadius = "50%";
            }

            container.appendChild(piece);
          }

          setTimeout(() => (container.innerHTML = ""), 4000);
        }

        // Show/hide spin button based on admin status
        function updateAdminUI(admin) {
          isAdmin = admin;
          const spinBtn = document.getElementById("spin-btn");
          if (spinBtn) {
            if (admin) {
              spinBtn.classList.remove("d-none");
            } else {
              spinBtn.classList.add("d-none");
            }
          }
        }

        // Listen for auth changes to show/hide admin button
        if (window.authHelpers && window.authHelpers.onChange) {
          window.authHelpers.onChange(async (user) => {
            if (user) {
              try {
                const tokenResult = await window.authHelpers.getIdTokenResult();
                updateAdminUI(tokenResult.claims.admin === true);
              } catch (e) {
                updateAdminUI(false);
              }
            } else {
              updateAdminUI(false);
            }
          });
        }

        // Initialize wheel when DOM is ready
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", initWheel);
        } else {
          initWheel();
        }
      })();
    </script>

    <!-- User Authentication & Profile Management -->
    <script>
      // Wait for authHelpers to be available (set by the Firebase module script)
      (function initUserAuth() {
        if (!window.authHelpers || !window.shared) {
          setTimeout(initUserAuth, 50);
          return;
        }

        // DOM Elements
        const authModal = document.getElementById("authModal");
        const authModalTitle = document.getElementById("authModalTitle");
        const authSigninView = document.getElementById("auth-signin-view");
        const authSignupView = document.getElementById("auth-signup-view");
        const authProfileView = document.getElementById("auth-profile-view");

        // Sign In elements
        const signinForm = document.getElementById("signin-form");
        const signinEmail = document.getElementById("signin-email");
        const signinPassword = document.getElementById("signin-password");
        const signinBtn = document.getElementById("signin-btn");
        const signinStatus = document.getElementById("signin-status");
        const showSignupBtn = document.getElementById("show-signup-btn");

        // Sign Up elements
        const signupForm = document.getElementById("signup-form");
        const signupDisplayname = document.getElementById("signup-displayname");
        const signupAlias = document.getElementById("signup-alias");
        const signupEmail = document.getElementById("signup-email");
        const signupPassword = document.getElementById("signup-password");
        const signupBtn = document.getElementById("signup-btn");
        const signupStatus = document.getElementById("signup-status");
        const showSigninBtn = document.getElementById("show-signin-btn");

        // Profile edit elements
        const profileSetupForm = document.getElementById("profile-setup-form");
        const profileSetupStatus = document.getElementById(
          "profile-setup-status"
        );
        const setupDisplayname = document.getElementById("setup-displayname");
        const setupAlias = document.getElementById("setup-alias");

        // User bar elements
        const userProfileBar = document.getElementById("user-profile-bar");
        const userDisplayName = document.getElementById("user-display-name");
        const userAliasSpan = document.getElementById("user-alias");
        const editProfileBtn = document.getElementById("edit-profile-btn");
        const userSignoutBtn = document.getElementById("user-signout-btn");

        // Submit score elements
        const submitGuestView = document.getElementById("submit-guest-view");
        const submitUserView = document.getElementById("submit-user-view");
        const submitSigninBtn = document.getElementById("submit-signin-btn");
        const entryForm = document.getElementById("entry-form");
        const submitStatus = document.getElementById("submit-status");

        // Use window scope so H2H section can access these
        window.currentUser = null;
        window.currentProfile = null;
        let bsAuthModal = null;
        let initialAuthCheckDone = false;

        // Initialize Bootstrap modal
        if (authModal && window.bootstrap) {
          bsAuthModal = new window.bootstrap.Modal(authModal);
        }

        // Show auth modal (sign in view)
        function showAuthModal(view) {
          view = view || "signin";
          if (bsAuthModal) {
            authSigninView.classList.toggle("d-none", view !== "signin");
            authSignupView.classList.toggle("d-none", view !== "signup");
            authProfileView.classList.toggle("d-none", view !== "profile");

            if (view === "signin") {
              authModalTitle.textContent = "Welcome Back!";
              signinStatus.textContent = "";
            } else if (view === "signup") {
              authModalTitle.textContent = "Create Account";
              signupStatus.textContent = "";
            } else if (view === "profile") {
              authModalTitle.textContent = "Edit Profile";
              profileSetupStatus.textContent = "";
            }

            bsAuthModal.show();
          }
        }

        // Make showAuthModal globally accessible for H2H section
        window.showAuthModal = showAuthModal;

        // Hide auth modal
        function hideAuthModal() {
          if (bsAuthModal) {
            bsAuthModal.hide();
          }
        }

        // Toggle between sign in and sign up views
        if (showSignupBtn) {
          showSignupBtn.addEventListener("click", function () {
            authSigninView.classList.add("d-none");
            authSignupView.classList.remove("d-none");
            authModalTitle.textContent = "Create Account";
            signupStatus.textContent = "";
          });
        }

        if (showSigninBtn) {
          showSigninBtn.addEventListener("click", function () {
            authSignupView.classList.add("d-none");
            authSigninView.classList.remove("d-none");
            authModalTitle.textContent = "Welcome Back!";
            signinStatus.textContent = "";
          });
        }

        // Sign In form submission
        if (signinForm) {
          signinForm.addEventListener("submit", async function (e) {
            e.preventDefault();

            const email = signinEmail.value.trim();
            const password = signinPassword.value;

            if (!email || !password) {
              signinStatus.textContent = "Please fill in all fields.";
              return;
            }

            try {
              signinBtn.disabled = true;
              signinBtn.textContent = "Signing in...";
              signinStatus.textContent = "";

              await window.authHelpers.signInWithEmail(email, password);
              // Auth state change will handle the rest
            } catch (err) {
              console.error("Sign in error:", err);
              signinBtn.disabled = false;
              signinBtn.textContent = "Sign In";

              // User-friendly error messages
              if (
                err.code === "auth/user-not-found" ||
                err.code === "auth/wrong-password" ||
                err.code === "auth/invalid-credential"
              ) {
                signinStatus.textContent = "Invalid email or password.";
              } else if (err.code === "auth/too-many-requests") {
                signinStatus.textContent =
                  "Too many attempts. Please try again later.";
              } else {
                signinStatus.textContent = "Error: " + err.message;
              }
            }
          });
        }

        // Sign Up form submission
        if (signupForm) {
          signupForm.addEventListener("submit", async function (e) {
            e.preventDefault();

            const displayName = signupDisplayname.value.trim();
            const alias = signupAlias.value.trim().toLowerCase();
            const email = signupEmail.value.trim();
            const password = signupPassword.value;

            if (!displayName || !alias || !email || !password) {
              signupStatus.textContent = "Please fill in all fields.";
              return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(alias)) {
              signupStatus.textContent =
                "Alias can only contain letters, numbers, and underscores.";
              return;
            }

            if (password.length < 6) {
              signupStatus.textContent =
                "Password must be at least 6 characters.";
              return;
            }

            try {
              signupBtn.disabled = true;
              signupBtn.textContent = "Creating account...";
              signupStatus.textContent = "";

              // Check if alias is available
              const aliasAvailable = await window.shared.checkAliasAvailable(
                alias,
                null
              );
              if (!aliasAvailable) {
                signupBtn.disabled = false;
                signupBtn.textContent = "Create Account";
                signupStatus.textContent =
                  "This alias is already taken. Please choose another.";
                return;
              }

              // Create the user account
              const userCredential = await window.authHelpers.createAccount(
                email,
                password
              );

              // Save the profile
              await window.shared.setUserProfile(userCredential.user.uid, {
                displayName: displayName,
                alias: alias,
                email: email,
                createdAt: Date.now(),
              });

              // Auth state change will handle the rest
            } catch (err) {
              console.error("Sign up error:", err);
              signupBtn.disabled = false;
              signupBtn.textContent = "Create Account";

              // User-friendly error messages
              if (err.code === "auth/email-already-in-use") {
                signupStatus.textContent =
                  "This email is already registered. Try signing in instead.";
              } else if (err.code === "auth/weak-password") {
                signupStatus.textContent =
                  "Password is too weak. Use at least 6 characters.";
              } else if (err.code === "auth/invalid-email") {
                signupStatus.textContent =
                  "Please enter a valid email address.";
              } else {
                signupStatus.textContent = "Error: " + err.message;
              }
            }
          });
        }

        // Submit sign in button (in the submit score section)
        if (submitSigninBtn) {
          submitSigninBtn.addEventListener("click", function () {
            showAuthModal("signin");
          });
        }

        // Profile edit form
        if (profileSetupForm) {
          profileSetupForm.addEventListener("submit", async function (e) {
            e.preventDefault();

            const displayName = setupDisplayname.value.trim();
            const alias = setupAlias.value.trim().toLowerCase();

            if (!displayName || !alias) {
              profileSetupStatus.textContent = "Please fill in all fields.";
              return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(alias)) {
              profileSetupStatus.textContent =
                "Alias can only contain letters, numbers, and underscores.";
              return;
            }

            try {
              profileSetupStatus.textContent = "Saving...";

              // Check if alias is available (allow keeping current alias)
              const available = await window.shared.checkAliasAvailable(
                alias,
                currentUser.uid
              );
              if (!available) {
                profileSetupStatus.textContent =
                  "This alias is already taken. Please choose another.";
                return;
              }

              // Save profile
              await window.shared.setUserProfile(window.currentUser.uid, {
                displayName: displayName,
                alias: alias,
              });

              window.currentProfile = {
                displayName: displayName,
                alias: alias,
              };
              hideAuthModal();
              updateUIForUser();
            } catch (err) {
              console.error("Profile save error:", err);
              profileSetupStatus.textContent =
                "Error saving profile: " + err.message;
            }
          });
        }

        // Sign out button
        if (userSignoutBtn) {
          userSignoutBtn.addEventListener("click", async function () {
            try {
              await window.authHelpers.signOut();
            } catch (e) {
              console.error("Sign out error:", e);
            }
          });
        }

        // Edit profile button
        if (editProfileBtn) {
          editProfileBtn.addEventListener("click", function () {
            if (window.currentProfile) {
              setupDisplayname.value = window.currentProfile.displayName || "";
              setupAlias.value = window.currentProfile.alias || "";
            }
            showAuthModal("profile");
          });
        }

        // Update UI based on user state
        function updateUIForUser() {
          if (window.currentUser && window.currentProfile) {
            // Logged in with profile
            userProfileBar.classList.remove("d-none");
            userDisplayName.textContent = window.currentProfile.displayName;
            userAliasSpan.textContent = window.currentProfile.alias;

            submitGuestView.classList.add("d-none");
            submitUserView.classList.remove("d-none");

            // Update H2H section for logged-in user
            if (typeof window.updateH2HAuthUI === "function") {
              window.updateH2HAuthUI(window.currentUser, window.currentProfile);
            }
          } else {
            // Not logged in or no profile
            userProfileBar.classList.add("d-none");
            submitGuestView.classList.remove("d-none");
            submitUserView.classList.add("d-none");

            // Update H2H section for logged-out user
            if (typeof window.updateH2HAuthUI === "function") {
              window.updateH2HAuthUI(null, null);
            }
          }
        }

        // Auth state change listener
        window.authHelpers.onChange(async function (user) {
          window.currentUser = user;

          // Reset form states
          if (signinBtn) {
            signinBtn.disabled = false;
            signinBtn.textContent = "Sign In";
          }
          if (signupBtn) {
            signupBtn.disabled = false;
            signupBtn.textContent = "Create Account";
          }

          if (user) {
            // User is signed in, load profile
            try {
              // Try to get profile, with retries for race condition during sign-up
              let retries = 3;
              let profile = null;

              while (retries > 0 && !profile) {
                profile = await window.shared.getUserProfile(user.uid);
                if (!profile && retries > 1) {
                  // Wait a bit and retry (profile might still be writing)
                  await new Promise((resolve) => setTimeout(resolve, 500));
                }
                retries--;
              }

              window.currentProfile = profile;

              if (window.currentProfile) {
                // Has profile, we're good
                hideAuthModal();
                updateUIForUser();
              } else {
                // No profile found after retries - this might be a new user
                // whose profile write failed, or an old account without profile.
                // Don't sign them out - just update UI without profile features
                console.log("User signed in but profile not found");
                updateUIForUser();
              }
            } catch (e) {
              console.error("Error loading profile:", e);
              updateUIForUser();
            }
          } else {
            // User not signed in
            window.currentProfile = null;
            updateUIForUser();

            // Only show sign in modal on initial page load, not on every auth change
            if (!initialAuthCheckDone) {
              initialAuthCheckDone = true;
              showAuthModal("signin");
            }
          }
        });

        // Handle score submission
        if (entryForm) {
          entryForm.addEventListener("submit", async function (e) {
            e.preventDefault();

            if (!window.currentUser || !window.currentProfile) {
              submitStatus.textContent = "Please sign in first.";
              return;
            }

            const fractionInput = document.getElementById("fraction");
            const timeLeftInput = document.getElementById("time-left");

            const fractionVal = fractionInput.value.trim();
            const timeLeftVal = timeLeftInput.value.trim();

            // Parse fraction
            const match = fractionVal.match(/^(\d+)\s*\/\s*(\d+)$/);
            if (!match) {
              submitStatus.textContent =
                "Invalid score format. Use num/den (e.g., 7/9)";
              return;
            }
            const num = parseInt(match[1], 10);
            const den = parseInt(match[2], 10);
            if (den === 0) {
              submitStatus.textContent = "Denominator cannot be zero.";
              return;
            }

            // Parse time left (mm:ss or m:ss or just seconds)
            var timeLeftSeconds = 0;
            const timeMatch = timeLeftVal.match(/^(\d+):(\d{2})$/);
            if (timeMatch) {
              timeLeftSeconds =
                parseInt(timeMatch[1], 10) * 60 + parseInt(timeMatch[2], 10);
            } else if (/^\d+$/.test(timeLeftVal)) {
              timeLeftSeconds = parseInt(timeLeftVal, 10);
            } else {
              submitStatus.textContent =
                "Invalid time format. Use mm:ss (e.g., 1:23)";
              return;
            }

            try {
              submitStatus.textContent = "Submitting...";

              await window.shared.submitScore({
                alias: window.currentProfile.alias,
                displayName: window.currentProfile.displayName,
                num: num,
                den: den,
                ratio: num / den,
                timeLeft: timeLeftSeconds,
              });

              fractionInput.value = "";
              timeLeftInput.value = "";
              submitStatus.textContent = "‚úì Score submitted!";

              setTimeout(function () {
                if (submitStatus.textContent === "‚úì Score submitted!") {
                  submitStatus.textContent = "";
                }
              }, 3000);
            } catch (err) {
              console.error("Submit error:", err);
              submitStatus.textContent = "Error: " + err.message;
            }
          });
        }

        // Expose for other scripts
        window.userAuth = {
          getCurrentUser: function () {
            return window.currentUser;
          },
          getCurrentProfile: function () {
            return window.currentProfile;
          },
          showAuthModal: showAuthModal,
        };
      })();
    </script>

    <!-- Bootstrap JS bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Your app logic -->
    <script src="app.js" defer></script>
  </body>
</html>
