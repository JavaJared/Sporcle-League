<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sporcle League</title>

    <!-- Bootstrap -->
    <!-- In <head>, replace your existing Bootstrap link -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootswatch@5/dist/minty/bootstrap.min.css"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="styles.css" />

    <style>
      /* small polish so Bootstrap themes apply everywhere */
      html,
      body {
        height: 100%;
      }
      body {
        background: var(--bs-body-bg);
        color: var(--bs-body-color);
      }
      .card {
        border-radius: 12px;
      }
      .card .card-body {
        padding: 16px;
      }
      .table td,
      .table th {
        vertical-align: middle;
      }
      .note {
        opacity: 0.7;
      }
      /* Playoff Bracket Styles */
      .playoff-bracket {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        gap: 40px;
        overflow-x: auto;
        padding: 20px;
      }

      .bracket-round {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        min-width: 200px;
        flex-shrink: 0;
      }

      .bracket-round-title {
        text-align: center;
        font-weight: bold;
        margin-bottom: 15px;
        font-size: 0.9rem;
        text-transform: uppercase;
        color: var(--bs-secondary);
      }

      .bracket-match {
        background: var(--bs-card-bg);
        border: 2px solid var(--bs-border-color);
        border-radius: 8px;
        margin: 10px 0;
        padding: 8px;
        position: relative;
      }

      .bracket-match.completed {
        border-color: var(--bs-success);
      }

      .bracket-match.active {
        border-color: var(--bs-primary);
        box-shadow: 0 0 10px rgba(13, 110, 253, 0.3);
      }

      .bracket-player {
        padding: 8px;
        margin: 2px 0;
        border-radius: 4px;
        background: var(--bs-body-bg);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
      }

      .bracket-player.winner {
        background: var(--bs-success);
        color: white;
        font-weight: bold;
      }

      .bracket-player.loser {
        opacity: 0.5;
      }

      .bracket-player.tbd {
        font-style: italic;
        opacity: 0.6;
      }

      .bracket-seed {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-right: 5px;
      }

      .bracket-connector {
        position: absolute;
        right: -40px;
        top: 50%;
        width: 40px;
        height: 2px;
        background: var(--bs-border-color);
        transform: translateY(-50%);
      }
    </style>
    <!-- React for Playoff Bracket -->
    <script
      src="https://unpkg.com/react@18/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
      crossorigin
    ></script>
  </head>
  <body class="bg-body text-body">
    <!-- Header -->
    <header class="container my-2">
      <div class="d-flex flex-wrap align-items-center gap-2">
        <h1 class="m-0 flex-grow-1">Sporcle League</h1>
        <span id="status" class="badge text-bg-secondary">Ready</span>
        <button
          id="account-signout"
          class="btn btn-outline-danger btn-sm d-none"
        >
          Sign out
        </button>
        <!-- In the header button group -->
        <button id="admin-signin-header" class="btn btn-outline-primary btn-sm">
          Admin sign in
        </button>
      </div>
    </header>

    <main class="container">
      <!-- Always visible: Today's Quiz -->
      <section class="card mb-3">
        <div class="card-body d-flex align-items-center flex-wrap gap-2">
          <span class="text-secondary">Todayâ€™s Quiz:</span>
          <a id="quiz-link-display" href="#" target="_blank"
            >No quiz link posted yet.</a
          >
          <!-- admin-only form; JS will show/hide -->
          <form id="quiz-form" class="d-inline-flex gap-2 ms-auto d-none">
            <input
              id="quiz-url"
              class="form-control"
              type="url"
              placeholder="https://example.com/quiz"
              required
            />
            <button type="submit" class="btn btn-outline-primary">
              Submit
            </button>
          </form>
        </div>
      </section>

      <!-- Always visible: Submit Score -->
      <section class="card mb-3">
        <div class="card-body">
          <h2 class="h5 mb-3">Submit Score</h2>
          <form id="entry-form" class="d-flex flex-wrap gap-2">
            <input
              id="name"
              class="form-control"
              type="text"
              placeholder="Display name"
              required
            />
            <input
              id="alias"
              class="form-control"
              type="text"
              placeholder="Alias"
              required
            />
            <input
              id="fraction"
              class="form-control"
              type="text"
              placeholder="Score (e.g., 7/9)"
              required
            />
            <button type="submit" class="btn btn-primary">Submit</button>
          </form>
        </div>
      </section>

      <!-- Bootstrap Tabs -->
      <ul
        class="nav nav-pills nav-fill gap-2 small bg-body-tertiary rounded-3 p-2"
        id="mainTabs"
        role="tablist"
      >
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            data-bs-toggle="tab"
            data-bs-target="#tab-today"
            type="button"
            role="tab"
          >
            Todayâ€™s Standings
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-points"
            type="button"
            role="tab"
          >
            Season Standings
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-fame"
            type="button"
            role="tab"
          >
            Wall of Fame
          </button>
        </li>
        <!--<li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-shame"
            type="button"
            role="tab"
          >
            Participation Pavilion
          </button>
        </li>-->
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            data-bs-toggle="tab"
            data-bs-target="#tab-playoffs"
            type="button"
            role="tab"
          >
            Playoffs
          </button>
        </li>

        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="h2h-tab"
            data-bs-toggle="tab"
            data-bs-target="#tab-headtohead"
            type="button"
            role="tab"
          >
            Head to Head
          </button>
        </li>

        <!-- In your tabs UL -->
        <li class="nav-item" role="presentation" id="nav-admin-item">
          <button
            class="nav-link"
            id="admin-tab-btn"
            data-bs-toggle="tab"
            data-bs-target="#tab-admin"
            type="button"
            role="tab"
          >
            Admin
          </button>
        </li>
      </ul>

      <div class="tab-content py-3">
        <!-- Todayâ€™s Standings -->
        <div class="tab-pane fade show active" id="tab-today" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Todayâ€™s Standings</h2>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Score</th>
                      <th>%</th>
                      <th id="standings-actions-th" style="width: 170px">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody id="standings-body"></tbody>
                </table>
              </div>
              <div id="empty-standings" class="note">No entries yet today.</div>
            </div>
          </section>
        </div>

        <!-- All-Time Points -->
        <div class="tab-pane fade" id="tab-points" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Season Standings</h2>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Points</th>
                    </tr>
                  </thead>
                  <tbody id="points-body"></tbody>
                </table>
              </div>
              <div id="empty-points" class="note">No points yet.</div>
            </div>
          </section>
        </div>

        <!-- Wall of Fame -->
        <div class="tab-pane fade" id="tab-fame" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Wall of Fame</h2>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Firsts</th>
                    </tr>
                  </thead>
                  <tbody id="fame-body"></tbody>
                </table>
              </div>
              <div id="empty-fame" class="note">No data yet.</div>
            </div>
          </section>
        </div>

        <!-- Wall of Shame -->
        <div class="tab-pane fade" id="tab-shame" role="tabpanel">
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Participation Pavilion</h2>
              <div class="note mt-2">
                An ode to those who gave it their all and fell just a little
                short.
              </div>
              <div class="table-responsive">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      <th style="width: 64px">#</th>
                      <th>Name</th>
                      <th>Lasts</th>
                    </tr>
                  </thead>
                  <tbody id="shame-body"></tbody>
                </table>
              </div>
              <div id="empty-shame" class="note">No data yet.</div>
            </div>
          </section>
        </div>

        <!-- Playoffs tab -->
        <div
          class="tab-pane fade"
          id="tab-playoffs"
          role="tabpanel"
          aria-labelledby="tab-playoffs-tab"
        >
          <!-- Join Playoff Match (only shown after Finalize Playoffs) -->
          <div id="playoff-join-card" class="card mb-3">
            <div class="card-body">
              <h5 class="card-title">Playoff Match</h5>
              <p class="card-text">
                Enter your alias to join your assigned playoff matchup.
              </p>

              <form id="playoff-join-form" class="row g-2">
                <div class="col-sm-4">
                  <label for="playoff-alias" class="form-label">Alias</label>
                  <input
                    type="text"
                    id="playoff-alias"
                    class="form-control"
                    placeholder="ellisjf"
                    required
                  />
                </div>

                <div class="col-sm-4 align-self-end">
                  <button type="submit" class="btn btn-primary">
                    Join Playoff Match
                  </button>
                </div>
              </form>

              <div id="playoff-join-status" class="form-text mt-2"></div>
            </div>
          </div>

          <!-- Bracket (always visible) -->
          <section class="card">
            <div class="card-body">
              <h2 class="h5 mb-3">Playoffs</h2>

              <div id="playoffs-bracket" class="playoff-bracket">
                <!-- Dynamic bracket will be rendered here -->
              </div>

              <div class="note mt-2">
                Bracket is seeded by Season Standings. Later rounds will be
                filled in as winners are decided.
              </div>
            </div>
          </section>
        </div>

        <!-- Head to Head -->
        <div class="tab-pane fade" id="tab-headtohead" role="tabpanel">
          <section class="card mt-3">
            <div class="card-body">
              <h2 class="h5 mb-3">Head to Head</h2>

              <form id="h2h-form" class="row g-2 mb-3">
                <div class="col-md-4">
                  <label for="h2h-name" class="form-label">Display Name</label>
                  <input
                    type="text"
                    id="h2h-name"
                    class="form-control"
                    placeholder="Your Name"
                    required
                  />
                </div>
                <div class="col-md-4">
                  <label for="h2h-alias" class="form-label">Alias</label>
                  <input
                    type="text"
                    id="h2h-alias"
                    class="form-control"
                    placeholder="ellisjf"
                    required
                  />
                </div>
                <div class="col-md-4 d-flex align-items-end">
                  <button
                    type="submit"
                    class="btn btn-primary w-100"
                    id="h2h-find-btn"
                  >
                    Find Match
                  </button>
                </div>
              </form>

              <button
                id="h2h-cancel-btn"
                class="btn btn-outline-secondary btn-sm mb-3 d-none"
              >
                Cancel Matchmaking
              </button>

              <div id="h2h-status" class="mb-2 text-muted">
                Enter your name and alias, then click "Find Match" to join the
                queue.
              </div>

              <!-- Match info once paired -->
              <div id="h2h-match-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">You have been matched!</h3>
                  <p class="mb-1">
                    <strong>You:</strong> <span id="h2h-you-name"></span> (<span
                      id="h2h-you-alias"
                    ></span
                    >)
                  </p>
                  <p class="mb-1">
                    <strong>Opponent:</strong>
                    <span id="h2h-opp-name"></span> (<span
                      id="h2h-opp-alias"
                    ></span
                    >)
                  </p>
                  <p class="mb-1">
                    <strong>Quiz:</strong>
                    <button
                      id="h2h-veto-btn"
                      class="btn btn-warning btn-sm ms-2 d-none"
                    >
                      Use Veto
                    </button>

                    <a href="#" target="_blank" id="h2h-quiz-link">Open quiz</a>
                  </p>
                </div>
              </div>

              <!-- Your score entry (only you edit yours) -->
              <div id="h2h-score-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">Submit Your Result</h3>
                  <form id="h2h-score-form" class="row g-2">
                    <div class="col-md-6">
                      <label for="h2h-score" class="form-label">
                        Your Score (num/den)
                      </label>
                      <input
                        type="text"
                        id="h2h-score"
                        class="form-control"
                        placeholder="10/15"
                        required
                      />
                    </div>
                    <div class="col-md-4">
                      <label for="h2h-time" class="form-label">
                        Time Left (mm:ss)
                      </label>
                      <input
                        type="text"
                        id="h2h-time"
                        class="form-control"
                        placeholder="01:23"
                        required
                      />
                    </div>
                    <div class="col-md-2 d-flex align-items-end">
                      <button
                        type="submit"
                        class="btn btn-success w-100"
                        id="h2h-score-submit-btn"
                      >
                        Submit
                      </button>
                    </div>
                  </form>
                  <div id="h2h-score-status" class="form-text mt-1"></div>
                </div>
              </div>

              <!-- Final results, shown only after both players submitted -->
              <div id="h2h-result-card" class="card d-none mb-3">
                <div class="card-body">
                  <h3 class="h6 mb-2">Match Result</h3>
                  <p class="mb-1" id="h2h-result-summary"></p>
                  <ul class="mb-0 small" id="h2h-result-detail"></ul>
                </div>
              </div>

              <!-- Standings table -->
              <div class="mt-4">
                <h3 class="h6">Head-to-Head Standings</h3>
                <div class="table-responsive">
                  <table
                    class="table table-sm align-middle"
                    id="h2h-standings-table"
                  >
                    <thead>
                      <tr>
                        <th>#</th>
                        <th>Display Name</th>
                        <th>Alias</th>
                        <th>W</th>
                        <th>L</th>
                        <th>Streak</th>
                        <th>Best Streak</th>
                        <th>Win%</th>
                      </tr>
                    </thead>

                    <tbody id="h2h-standings-body">
                      <!-- filled by JS -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
        </div>

        <!-- Admin -->
        <div class="tab-pane fade" id="tab-admin" role="tabpanel">
          <section class="card" id="admin-panel">
            <div class="card-body">
              <h2 class="h5 mb-3">Admin</h2>

              <!-- Auth controls (Google sign in restored) -->
              <div class="d-flex flex-wrap gap-2 mb-2">
                <button id="admin-signin" class="btn btn-secondary">
                  Admin: Sign in with Google
                </button>
                <button
                  id="grant-admin"
                  class="btn btn-outline-secondary d-none"
                >
                  Grant Admin to me
                </button>
                <button id="admin-signout" class="btn btn-warning d-none">
                  Sign out (admin)
                </button>
              </div>

              <!-- Day controls -->
              <div class="d-flex flex-wrap gap-2 mb-3">
                <button id="finish-day" class="btn btn-primary">
                  Finish Day (award points)
                </button>
                <button id="reset-scores" class="btn btn-danger">
                  Reset Scores
                </button>
              </div>

              <!-- Delete from leaderboard -->
              <h3 class="h6 mt-2 mb-2">Delete From Leaderboard</h3>
              <form id="delete-points-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="delete-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or existing doc ID"
                  required
                />
                <button type="submit" class="btn btn-danger">Delete</button>
              </form>

              <!-- Edit points -->
              <h3 class="h6 mt-2 mb-2">Edit Points</h3>
              <form id="points-edit-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="pe-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or doc ID"
                  required
                />
                <select id="pe-mode" class="form-select">
                  <option value="set">Set to value</option>
                  <option value="inc">Increment by</option>
                </select>
                <input
                  id="pe-value"
                  class="form-control"
                  type="number"
                  placeholder="Points"
                  required
                />
                <input
                  id="pe-dn"
                  class="form-control"
                  type="text"
                  placeholder="Display name (optional)"
                />
                <button type="submit" class="btn btn-primary">Apply</button>
              </form>

              <!-- Retro finishes -->
              <h3 class="h6 mt-2 mb-2">Retroactively Set Firsts/Lasts</h3>
              <form id="finishes-edit-form" class="d-flex flex-wrap gap-2 mb-3">
                <input
                  id="fe-docid"
                  class="form-control"
                  type="text"
                  placeholder="Alias or doc ID"
                  required
                />
                <select id="fe-mode" class="form-select">
                  <option value="set">Set</option>
                  <option value="inc">Increment</option>
                </select>
                <input
                  id="fe-firsts"
                  class="form-control"
                  type="number"
                  placeholder="Firsts"
                />
                <input
                  id="fe-lasts"
                  class="form-control"
                  type="number"
                  placeholder="Lasts"
                />
                <button type="submit" class="btn btn-primary">Apply</button>
              </form>

              <!-- Playoff Controls -->
              <div class="card mb-3">
                <div class="card-body">
                  <h5 class="card-title">Playoffs Control</h5>
                  <p class="card-text">
                    Use this to finalize the playoffs bracket and enable playoff
                    features for everyone.
                  </p>
                  <button
                    id="playoffs-finalize-btn"
                    class="btn btn-danger btn-sm"
                  >
                    Finalize Playoffs
                  </button>
                  <button
                    id="playoffs-unfinalize-btn"
                    class="btn btn-outline-secondary btn-sm ms-2 d-none"
                  >
                    Reopen Playoffs (Admin only)
                  </button>
                  <button id="add-seeds-btn" class="btn btn-info btn-sm ms-2">
                    Add Seeds to Bracket
                  </button>
                  <button
                    id="reset-bracket-btn"
                    class="btn btn-outline-danger btn-sm ms-2"
                  >
                    ðŸ”„ Reset & Initialize Bracket
                  </button>
                  <div
                    id="playoffs-finalize-status"
                    class="form-text mt-2"
                  ></div>
                </div>
              </div>

              <!-- Manual Playoff Result Entry -->
              <div class="card mb-3">
                <div class="card-body">
                  <h5 class="card-title">Manual Playoff Result Entry</h5>
                  <p class="card-text">
                    Manually set the winner for a playoff matchup. This is
                    useful for entering results of matches that were played
                    offline.
                  </p>

                  <form id="manual-playoff-result-form" class="row g-2">
                    <div class="col-md-3">
                      <label for="playoff-round" class="form-label"
                        >Round</label
                      >
                      <input
                        type="number"
                        id="playoff-round"
                        class="form-control"
                        placeholder="1"
                        min="1"
                        required
                      />
                    </div>

                    <div class="col-md-3">
                      <label for="playoff-match-index" class="form-label"
                        >Match Index</label
                      >
                      <input
                        type="number"
                        id="playoff-match-index"
                        class="form-control"
                        placeholder="0"
                        min="0"
                        required
                      />
                    </div>

                    <div class="col-md-4">
                      <label for="playoff-winner-alias" class="form-label"
                        >Winner Alias</label
                      >
                      <input
                        type="text"
                        id="playoff-winner-alias"
                        class="form-control"
                        placeholder="jdoe"
                        required
                      />
                    </div>

                    <div class="col-md-2 d-flex align-items-end">
                      <button type="submit" class="btn btn-warning w-100">
                        Set Winner
                      </button>
                    </div>
                  </form>

                  <div id="manual-playoff-status" class="form-text mt-2"></div>

                  <hr class="my-3" />

                  <h6>Quick Match Lookup</h6>
                  <div class="table-responsive mt-2">
                    <table
                      class="table table-sm table-bordered"
                      id="playoff-matches-table"
                    >
                      <thead>
                        <tr>
                          <th>Round</th>
                          <th>Match #</th>
                          <th>Player 1</th>
                          <th>Player 2</th>
                          <th>Status</th>
                          <th>Winner</th>
                          <th>Action</th>
                        </tr>
                      </thead>
                      <tbody id="playoff-matches-body">
                        <!-- Filled by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <!-- Alias migration -->
              <h3 class="h6 mt-2 mb-2">Alias Migration</h3>
              <form id="alias-migrate-form" class="d-flex flex-wrap gap-2">
                <input
                  id="old-id"
                  class="form-control"
                  type="text"
                  placeholder="Old points doc id (e.g., old name)"
                  required
                />
                <input
                  id="new-alias"
                  class="form-control"
                  type="text"
                  placeholder="New alias (e.g., jdoe42)"
                  required
                />
                <input
                  id="new-dn"
                  class="form-control"
                  type="text"
                  placeholder="Display name (optional)"
                />
                <button type="submit" class="btn btn-primary">
                  Move/Merge
                </button>
              </form>
            </div>
          </section>
        </div>
      </div>
    </main>

    <!-- Firebase + module: exposes helpers used by app.js -->
    <script type="module">
      // Firebase SDK imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signInAnonymously,
        GoogleAuthProvider,
        signInWithPopup,
        signOut,
        getIdTokenResult,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
      import {
        getFirestore,
        collection,
        doc,
        addDoc,
        getDocs,
        getDoc,
        query,
        where,
        orderBy,
        limit,
        serverTimestamp,
        writeBatch,
        setDoc,
        runTransaction,
        deleteDoc,
        updateDoc,
        Timestamp,
        onSnapshot,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import {
        getFunctions,
        httpsCallable,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-functions.js";

      // Replace with your real config from Firebase console
      const firebaseConfig = {
        apiKey: "AIzaSyCljmg5V4r0q7vZ5X6K5Wn78iTT7PtKIqU",
        authDomain: "sporcle-league-ced80.firebaseapp.com",
        projectId: "sporcle-league-ced80",
        storageBucket: "sporcle-league-ced80.firebasestorage.app",
        messagingSenderId: "34922576123",
        appId: "1:34922576123:web:429c7e4568455c6d4d185e",
        measurementId: "G-8V028YY2NK",
      };

      // 2) Init Firebase
      const app = initializeApp(firebaseConfig);
      console.log("firebaseConfig.projectId =", firebaseConfig.projectId);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const functions = getFunctions(app);
      const provider = new GoogleAuthProvider();

      // 3) Theme toggle (affects entire page via Bootstrap color modes)
      (function themeInit() {
        var key = "bsTheme";
        var btn = document.getElementById("theme-toggle");
        var root = document.documentElement;
        function apply(t) {
          root.setAttribute("data-bs-theme", t);
          if (btn) btn.textContent = t === "dark" ? "ðŸŒ™" : "ðŸŒž";
          try {
            localStorage.setItem(key, t);
          } catch (e) {}
        }
        var saved = null;
        try {
          saved = localStorage.getItem(key);
        } catch (e) {}
        apply(saved === "light" ? "light" : "dark");
        if (btn)
          btn.addEventListener("click", function () {
            var next =
              root.getAttribute("data-bs-theme") === "dark" ? "light" : "dark";
            apply(next);
          });
      })();

      // 4) Firestore refs
      const todayCol = collection(db, "today");
      console.log("todayCol path =", todayCol.path);
      const pointsCol = collection(db, "points");
      const quizDoc = doc(db, "quizLink", "today");

      // 5) Expose app helpers used by app.js
      window.shared = {
        // Today submissions (alias is the doc id)
        submitScore: async function ({ alias, displayName, num, den, ratio }) {
          var id = String(alias || "")
            .trim()
            .toLowerCase();
          if (!id) throw new Error("Alias required");
          await setDoc(
            doc(todayCol, id),
            {
              alias: id,
              displayName: displayName,
              num: num,
              den: den,
              ratio: ratio,
              t: Date.now(),
            },
            { merge: true }
          );
        },
        deleteEntry: async function (alias) {
          var id = String(alias || "")
            .trim()
            .toLowerCase();
          await deleteDoc(doc(todayCol, id));
        },
        upsertEntry: async function ({
          oldAlias,
          newAlias,
          displayName,
          num,
          den,
        }) {
          var src = String(oldAlias || "")
            .trim()
            .toLowerCase();
          var dst = String(newAlias || oldAlias || "")
            .trim()
            .toLowerCase();
          var ratio = num / den;
          await setDoc(
            doc(todayCol, dst),
            {
              alias: dst,
              displayName: displayName,
              num: num,
              den: den,
              ratio: ratio,
              t: Date.now(),
            },
            { merge: true }
          );
          if (dst !== src) await deleteDoc(doc(todayCol, src));
        },

        // Live listeners
        listenToday: function (cb) {
          return onSnapshot(todayCol, cb, function (err) {
            console.error("[today] err:", err);
          });
        },
        listenPoints: function (cb) {
          return onSnapshot(pointsCol, cb, function (err) {
            console.error("[points] err:", err);
          });
        },

        // Quiz link
        setQuizLink: async function (url) {
          await setDoc(
            quizDoc,
            { url: url, updated: Date.now() },
            { merge: true }
          );
        },
        listenQuizLink: function (cb) {
          return onSnapshot(quizDoc, cb);
        },

        // Callables (admin)
        finishDay: httpsCallable(functions, "finishDayAwardPoints"),
        resetScores: httpsCallable(functions, "resetAllPoints"),
        makeAdmin: httpsCallable(functions, "makeMeAdmin"),
        adminMovePoints: httpsCallable(functions, "adminMovePoints"),
        adminSetAliasFields: httpsCallable(functions, "adminSetAliasFields"),
        adminDeletePoints: httpsCallable(functions, "adminDeletePointsDoc"),
        adminUpdatePoints: httpsCallable(functions, "adminUpdatePoints"),
        adminUpdateFinishes: httpsCallable(functions, "adminUpdateFinishes"),
      };

      // 6) Auth helpers for app.js and buttons
      window.authHelpers = {
        signInAsAdmin: async function () {
          await signInWithPopup(auth, provider);
          if (auth.currentUser) {
            await auth.currentUser.getIdToken(true);
          }
        },
        signOut: function () {
          return signOut(auth);
        },
        onChange: function (cb) {
          return onAuthStateChanged(auth, cb);
        },
        getIdTokenResult: function () {
          return getIdTokenResult(auth.currentUser);
        },
      };

      // 7) Admin UI control: header sign in, hide Admin tab when not admin
      var navAdminItem = document.getElementById("nav-admin-item"); // <li> wrapper of Admin tab
      var adminTabBtn = document.getElementById("admin-tab-btn"); // <button> Admin tab
      var adminSigninHeader = document.getElementById("admin-signin-header"); // header "Admin sign in" button
      var globalOutBtn = document.getElementById("account-signout"); // global sign out button

      function toggleAdminUI(isAdmin) {
        // Show or hide Admin tab
        if (navAdminItem) navAdminItem.classList.toggle("d-none", !isAdmin);

        // If user is not admin but Admin tab is active, switch to first visible tab
        if (
          !isAdmin &&
          adminTabBtn &&
          adminTabBtn.classList.contains("active")
        ) {
          var firstTabBtn = document.querySelector(
            "#mainTabs .nav-link:not(.d-none)"
          );
          if (firstTabBtn && window.bootstrap && window.bootstrap.Tab) {
            new window.bootstrap.Tab(firstTabBtn).show();
          }
        }

        // Header admin sign in only when not admin
        if (adminSigninHeader)
          adminSigninHeader.classList.toggle("d-none", !!isAdmin);

        // Let app.js reveal per-element admin controls
        try {
          if (typeof window.refreshAdminUI === "function")
            window.refreshAdminUI(isAdmin);
        } catch (e) {}
      }

      async function signInWithGoogle() {
        await signInWithPopup(auth, provider);
        if (auth.currentUser) await auth.currentUser.getIdToken(true);
      }

      if (adminSigninHeader) {
        adminSigninHeader.addEventListener("click", function () {
          signInWithGoogle().catch(function (e) {
            console.error(e);
          });
        });
      }

      if (globalOutBtn) {
        globalOutBtn.addEventListener("click", function () {
          signOut(auth)
            .then(function () {
              location.reload();
            })
            .catch(function (e) {
              console.error(e);
            });
        });
      }

      // 8) Auth state and claims watcher
      onAuthStateChanged(auth, async (u) => {
        if (!u) {
          // Allow anonymous users (so they can submit scores)
          try {
            await signInAnonymously(auth);
          } catch (e) {}
          toggleAdminUI(false);
          if (globalOutBtn) globalOutBtn.classList.add("d-none");
          return;
        }

        try {
          // Check custom claims
          const token = await getIdTokenResult(u, true);
          const isAdmin = !!(
            token &&
            token.claims &&
            token.claims.admin === true
          );
          window.__isAdmin = isAdmin;

          // Only show the Sign Out button for admins
          if (globalOutBtn) globalOutBtn.classList.toggle("d-none", !isAdmin);

          toggleAdminUI(isAdmin);
        } catch (e) {
          console.error("claims error", e);
          window.__isAdmin = false;
          if (globalOutBtn) globalOutBtn.classList.add("d-none");
          toggleAdminUI(false);
        }
      });

      // Head-to-Head DOM elements (add to your existing references)
      const h2hForm = document.getElementById("h2h-form");
      const h2hNameInput = document.getElementById("h2h-name");
      const h2hAliasInput = document.getElementById("h2h-alias");
      const h2hStatus = document.getElementById("h2h-status");
      const h2hMatchCard = document.getElementById("h2h-match-card");
      const h2hYouName = document.getElementById("h2h-you-name");
      const h2hYouAlias = document.getElementById("h2h-you-alias");
      const h2hOppName = document.getElementById("h2h-opp-name");
      const h2hOppAlias = document.getElementById("h2h-opp-alias");
      const h2hQuizLink = document.getElementById("h2h-quiz-link");

      const h2hScoreCard = document.getElementById("h2h-score-card");
      const h2hScoreForm = document.getElementById("h2h-score-form");
      const h2hScoreInput = document.getElementById("h2h-score");
      const h2hTimeInput = document.getElementById("h2h-time");
      const h2hScoreStatus = document.getElementById("h2h-score-status");

      const h2hResultCard = document.getElementById("h2h-result-card");
      const h2hResultSummary = document.getElementById("h2h-result-summary");
      const h2hResultDetail = document.getElementById("h2h-result-detail");

      const h2hStandingsBody = document.getElementById("h2h-standings-body");

      let h2hQueueUnsub = null;
      let h2hQueueDocRef = null;
      let h2hCurrentMatchRef = null;
      let h2hCurrentSide = null; // "playerA" or "playerB"
      let h2hYouData = null; // {displayName, alias, clientId}

      let h2hQueueStartTime = null;
      let h2hQueueIntervalId = null;
      let h2hQueueTimeoutId = null;

      let h2hMatchShownOnce = false;

      const H2H_QUEUE_TIMEOUT_SECONDS = 10 * 60; // 10 minutes

      const h2hCancelBtn = document.getElementById("h2h-cancel-btn");

      function clearHeadToHeadQueueTimers() {
        h2hQueueStartTime = null;
        if (h2hQueueIntervalId) {
          clearInterval(h2hQueueIntervalId);
          h2hQueueIntervalId = null;
        }
        if (h2hQueueTimeoutId) {
          clearTimeout(h2hQueueTimeoutId);
          h2hQueueTimeoutId = null;
        }
      }

      function startHeadToHeadQueueTimers() {
        clearHeadToHeadQueueTimers();
        h2hQueueStartTime = Date.now();

        // live "in queue" indicator
        h2hQueueIntervalId = setInterval(() => {
          if (!h2hQueueStartTime) return;
          const elapsedSec = Math.floor(
            (Date.now() - h2hQueueStartTime) / 1000
          );
          const pretty = formatSecondsAsMMSS(elapsedSec);
          setH2HStatus(`Waiting for an opponentâ€¦ In queue for ${pretty}`);
        }, 1000);

        // hard timeout at 10 minutes
        h2hQueueTimeoutId = setTimeout(() => {
          // if weâ€™re still waiting after 10 minutes, auto-cancel
          cancelHeadToHeadQueue(
            `Matchmaking timed out after ${formatSecondsAsMMSS(
              H2H_QUEUE_TIMEOUT_SECONDS
            )}. Please try again.`
          );
        }, H2H_QUEUE_TIMEOUT_SECONDS * 1000);
      }

      async function cancelHeadToHeadQueue(message) {
        clearHeadToHeadQueueTimers();

        if (h2hQueueUnsub) {
          h2hQueueUnsub();
          h2hQueueUnsub = null;
        }

        if (h2hQueueDocRef) {
          try {
            await deleteDoc(h2hQueueDocRef);
          } catch (err) {
            console.error("Error deleting queue doc on cancel", err);
          }
          h2hQueueDocRef = null;
        }

        h2hCurrentMatchRef = null;
        h2hCurrentSide = null;
        h2hYouData = null;

        if (h2hMatchCard) h2hMatchCard.classList.add("d-none");
        if (h2hScoreCard) h2hScoreCard.classList.add("d-none");
        if (h2hResultCard) h2hResultCard.classList.add("d-none");

        if (h2hScoreInput) {
          h2hScoreInput.disabled = false;
          h2hScoreInput.value = "";
        }
        if (h2hTimeInput) {
          h2hTimeInput.disabled = false;
          h2hTimeInput.value = "";
        }
        const submitBtn = document.getElementById("h2h-score-submit-btn");
        if (submitBtn) submitBtn.disabled = false;

        if (h2hCancelBtn) h2hCancelBtn.classList.add("d-none");

        setH2HStatus(message || "Matchmaking cancelled.");
      }

      if (h2hCancelBtn) {
        h2hCancelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          cancelHeadToHeadQueue();
        });
      }

      async function cleanupOldQueueEntries(db, clientId) {
        const queueRef = collection(db, "headtoheadQueue");
        const q = query(
          queueRef,
          where("clientId", "==", clientId),
          where("status", "==", "waiting")
        );
        const snap = await getDocs(q);
        if (snap.empty) return;

        const batch = writeBatch(db);
        snap.forEach((docSnap) => {
          batch.delete(docSnap.ref);
        });
        await batch.commit();
      }

      // ---- Head-to-Head: persistent client id per browser ----
      function getOrCreateHeadToHeadClientId() {
        const key = "h2hClientId";
        const existing = window.localStorage.getItem(key);
        if (existing) return existing;

        const newId =
          "h2h_" +
          Math.random().toString(36).slice(2) +
          Date.now().toString(36);

        window.localStorage.setItem(key, newId);
        return newId;
      }

      function parseScoreString(raw) {
        const s = (raw || "").trim();
        const parts = s.split("/");
        if (parts.length !== 2) return null;
        const correct = parseInt(parts[0], 10);
        const total = parseInt(parts[1], 10);
        if (
          !Number.isFinite(correct) ||
          !Number.isFinite(total) ||
          total <= 0 ||
          correct < 0 ||
          correct > total
        ) {
          return null;
        }
        return {
          rawScore: s,
          correct,
          total,
          pct: correct / total,
        };
      }

      function parseTimeString(raw) {
        const s = (raw || "").trim();
        if (!s) return null;

        // allow "mm:ss" or just "ss"
        const parts = s.split(":");

        let seconds;
        if (parts.length === 1) {
          const sec = Number(parts[0]);
          if (!Number.isFinite(sec) || sec < 0) return null;
          seconds = Math.floor(sec);
        } else if (parts.length === 2) {
          const min = Number(parts[0]);
          const sec = Number(parts[1]);
          if (
            !Number.isFinite(min) ||
            !Number.isFinite(sec) ||
            min < 0 ||
            sec < 0 ||
            sec >= 60
          ) {
            return null;
          }
          seconds = Math.floor(min * 60 + sec);
        } else {
          return null;
        }

        return seconds;
      }

      function formatSecondsAsMMSS(totalSeconds) {
        const s = Math.max(0, Math.floor(totalSeconds || 0));
        const m = Math.floor(s / 60);
        const sec = s % 60;
        const mm = String(m).padStart(2, "0");
        const ss = String(sec).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      function setH2HStatus(msg) {
        if (h2hStatus) h2hStatus.textContent = msg;
      }

      function showH2HMatch(matchData, you, opp, yourSideKey) {
        if (!matchData) return;

        h2hYouName.textContent = you.displayName;
        h2hYouAlias.textContent = you.alias;
        h2hOppName.textContent = opp.displayName;
        h2hOppAlias.textContent = opp.alias;
        h2hQuizLink.href = matchData.quizUrl;
        h2hQuizLink.textContent = matchData.quizUrl;

        h2hMatchCard.classList.remove("d-none");

        // score entry
        h2hScoreCard.classList.remove("d-none");
        h2hResultCard.classList.add("d-none");
        h2hScoreStatus.textContent =
          "Play the quiz, then submit your score and time.";

        h2hScoreInput.value = "";
        h2hTimeInput.value = "";

        // IMPORTANT: re-enable after previous match
        h2hScoreInput.disabled = false;
        h2hTimeInput.disabled = false;
        const submitBtn = document.getElementById("h2h-score-submit-btn");
        if (submitBtn) submitBtn.disabled = false;

        h2hCurrentSide = yourSideKey; // "playerA" or "playerB"
      }

      // ============================================================================
      // PLAYOFF SYSTEM - REWRITTEN
      // ============================================================================

      let __playoffsFinalized = false;
      let playoffCurrentMatchUnsub = null;
      let playoffMyMatchData = null; // stores {seriesId, matchDoc, myAlias, mySide}

      const playoffsConfigRef = doc(db, "config", "playoffs");
      const playoffsFinalizeBtn = document.getElementById(
        "playoffs-finalize-btn"
      );
      const playoffsUnfinalizeBtn = document.getElementById(
        "playoffs-unfinalize-btn"
      );
      const playoffsFinalizeStatus = document.getElementById(
        "playoffs-finalize-status"
      );
      const playoffJoinCard = document.getElementById("playoff-join-card");
      const playoffJoinForm = document.getElementById("playoff-join-form");
      const playoffAliasInput = document.getElementById("playoff-alias");
      const playoffJoinStatus = document.getElementById("playoff-join-status");
      const h2hVetoBtn = document.getElementById("h2h-veto-btn");

      // Listen to playoffs config to show/hide join form
      onSnapshot(
        playoffsConfigRef,
        (snap) => {
          const data = snap.exists() ? snap.data() : {};
          __playoffsFinalized = !!data.finalized;
          updatePlayoffsUIFromFlag();
        },
        (err) => {
          console.error("Error listening to playoffs config", err);
        }
      );

      function updatePlayoffsUIFromFlag() {
        if (playoffJoinCard) {
          playoffJoinCard.classList.toggle("d-none", !__playoffsFinalized);
        }
      }

      // Admin: Finalize playoffs
      if (playoffsFinalizeBtn) {
        playoffsFinalizeBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          try {
            await setDoc(
              playoffsConfigRef,
              { finalized: true, finalizedAt: serverTimestamp() },
              { merge: true }
            );
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Playoffs finalized!";
            }
          } catch (err) {
            console.error("Error finalizing playoffs", err);
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Error finalizing playoffs.";
            }
          }
        });
      }

      // Admin: Unfinalize playoffs
      if (playoffsUnfinalizeBtn) {
        playoffsUnfinalizeBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (!confirm("Reopen playoffs for editing?")) return;
          try {
            await setDoc(
              playoffsConfigRef,
              { finalized: false },
              { merge: true }
            );
            if (playoffsFinalizeStatus) {
              playoffsFinalizeStatus.textContent = "Playoffs reopened.";
            }
          } catch (err) {
            console.error("Error unfinalizing playoffs", err);
          }
        });
      }

      // Player: Join playoff match
      if (playoffJoinForm) {
        playoffJoinForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          if (!__playoffsFinalized) {
            playoffJoinStatus.textContent = "Playoffs are not finalized yet.";
            return;
          }

          const rawAlias = playoffAliasInput.value.trim();
          if (!rawAlias) {
            playoffJoinStatus.textContent = "Please enter your alias.";
            return;
          }
          const alias = rawAlias.toLowerCase();

          try {
            playoffJoinStatus.textContent = "Finding your playoff matchup...";

            // Find the player's current playoff series
            const seriesDoc = await findActivePlayoffSeriesForAlias(db, alias);
            if (!seriesDoc) {
              playoffJoinStatus.textContent =
                "No active playoff matchup found for that alias.";
              return;
            }

            const series = seriesDoc.data();
            const clientId = getOrCreateHeadToHeadClientId();

            // Determine player info
            const aliases = series.aliases || [];
            if (!aliases.includes(alias)) {
              playoffJoinStatus.textContent =
                "Alias not found in this matchup.";
              return;
            }

            const oppAlias = aliases.find((a) => a !== alias);
            if (!oppAlias) {
              playoffJoinStatus.textContent = "Could not determine opponent.";
              return;
            }

            // Get display names from points collection
            const myPointsDoc = await getDoc(
              doc(collection(db, "points"), alias)
            );
            const oppPointsDoc = await getDoc(
              doc(collection(db, "points"), oppAlias)
            );

            const myDisplayName = myPointsDoc.exists()
              ? myPointsDoc.data().displayName || alias
              : alias;
            const oppDisplayName = oppPointsDoc.exists()
              ? oppPointsDoc.data().displayName || oppAlias
              : oppAlias;

            playoffJoinStatus.textContent = `Joining match vs ${oppDisplayName}...`;

            // Join the queue and start match
            await joinPlayoffMatchQueue(
              db,
              seriesDoc,
              alias,
              myDisplayName,
              oppAlias,
              oppDisplayName,
              clientId
            );
          } catch (err) {
            console.error("Error joining playoff match", err);
            playoffJoinStatus.textContent =
              "Error joining playoff match. See console.";
          }
        });
      }

      /**
       * Find the active playoff series for a given alias
       * Returns the series document with lowest round that is not completed
       */
      async function findActivePlayoffSeriesForAlias(db, alias) {
        const ref = collection(db, "playoffSeries");
        const q = query(
          ref,
          where("aliases", "array-contains", alias),
          where("status", "in", ["pending", "active"])
        );
        const snap = await getDocs(q);

        if (snap.empty) return null;

        // Find earliest round that's not completed
        let best = null;
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (!best) {
            best = docSnap;
          } else {
            const bd = best.data();
            if ((d.round || 0) < (bd.round || 0)) {
              best = docSnap;
            }
          }
        });

        return best;
      }

      /**
       * Join the playoff queue and attempt to create match
       */
      async function joinPlayoffMatchQueue(
        db,
        seriesDoc,
        myAlias,
        myDisplayName,
        oppAlias,
        oppDisplayName,
        clientId
      ) {
        const seriesId = seriesDoc.id;
        const series = seriesDoc.data();

        // Use a single match document per series
        const matchRef = doc(collection(db, "playoffMatches"), seriesId);

        // Check if match already exists
        const matchSnap = await getDoc(matchRef);

        if (matchSnap.exists()) {
          // Match already created, just listen to it
          playoffJoinStatus.textContent = "Joining existing match...";
          listenToPlayoffMatch(db, matchRef, seriesDoc, myAlias, myDisplayName);
        } else {
          // Try to create the match
          await createPlayoffMatch(
            db,
            matchRef,
            seriesDoc,
            myAlias,
            myDisplayName,
            oppAlias,
            oppDisplayName,
            clientId
          );
        }
      }

      /**
       * Create a new playoff match document
       */
      async function createPlayoffMatch(
        db,
        matchRef,
        seriesDoc,
        myAlias,
        myDisplayName,
        oppAlias,
        oppDisplayName,
        clientId
      ) {
        const series = seriesDoc.data();
        const seriesId = seriesDoc.id;

        // Determine who is higher seed (assume first in aliases array is higher seed)
        const aliases = series.aliases || [];
        const higherAlias = aliases[0];
        const lowerAlias = aliases[1];

        const higherDisplayName =
          higherAlias === myAlias ? myDisplayName : oppDisplayName;
        const lowerDisplayName =
          lowerAlias === myAlias ? myDisplayName : oppDisplayName;

        const isHigher = myAlias === higherAlias;

        // Get a quiz URL (will be shown only to higher seed initially)
        const quizUrl = await getRandomPlayoffQuizUrl(db);

        const matchData = {
          seriesId: seriesId,
          round: series.round || 1,
          matchIndex: series.matchIndex || 0,
          status: "waiting_for_veto", // waiting for higher seed to veto or accept
          createdAt: serverTimestamp(),

          higherAlias: higherAlias,
          higherDisplayName: higherDisplayName,
          higherClientId: isHigher ? clientId : null,
          higherJoined: isHigher,

          lowerAlias: lowerAlias,
          lowerDisplayName: lowerDisplayName,
          lowerClientId: !isHigher ? clientId : null,
          lowerJoined: !isHigher,

          quizUrl: quizUrl,
          vetoDecisionMade: false,
          vetoUsed: false,

          higherScore: null,
          lowerScore: null,

          winnerAlias: null,
          completedAt: null,
        };

        try {
          // Use a transaction to create match and update series atomically
          await runTransaction(db, async (transaction) => {
            // Check if match already exists
            const matchSnap = await transaction.get(matchRef);
            if (matchSnap.exists()) {
              // Someone else already created it, just return
              return;
            }

            // Create the match
            transaction.set(matchRef, matchData);

            // Update series status
            transaction.update(doc(collection(db, "playoffSeries"), seriesId), {
              status: "active",
              matchId: matchRef.id,
            });
          });

          playoffJoinStatus.textContent =
            "Match created! Waiting for opponent...";

          // Start listening
          listenToPlayoffMatch(db, matchRef, seriesDoc, myAlias, myDisplayName);
        } catch (err) {
          if (err.code === "permission-denied") {
            console.error(
              "Permission denied creating playoff match. Check Firestore rules."
            );
            playoffJoinStatus.textContent =
              "Permission denied. Please sign in as admin or check Firestore rules.";
          } else {
            console.error("Error creating playoff match", err);
            playoffJoinStatus.textContent =
              "Error creating match: " + err.message;
          }
        }
      }

      /**
       * Listen to playoff match updates
       */
      function listenToPlayoffMatch(
        db,
        matchRef,
        seriesDoc,
        myAlias,
        myDisplayName
      ) {
        // Clean up previous listener
        if (playoffCurrentMatchUnsub) {
          playoffCurrentMatchUnsub();
          playoffCurrentMatchUnsub = null;
        }

        playoffCurrentMatchUnsub = onSnapshot(
          matchRef,
          async (snap) => {
            if (!snap.exists()) {
              playoffJoinStatus.textContent = "Match was removed.";
              return;
            }

            const match = snap.data();
            const isHigherSeed = match.higherAlias === myAlias;
            const mySide = isHigherSeed ? "higher" : "lower";
            const oppSide = isHigherSeed ? "lower" : "higher";

            // Update join status if opponent hasn't joined yet
            const oppJoined = match[`${oppSide}Joined`];
            if (!oppJoined) {
              playoffJoinStatus.textContent = "Waiting for opponent to join...";
            } else {
              playoffJoinStatus.textContent = "Both players joined!";
            }

            // Update match document with my client ID if not set
            if (!match[`${mySide}ClientId`] || !match[`${mySide}Joined`]) {
              const clientId = getOrCreateHeadToHeadClientId();
              try {
                await updateDoc(matchRef, {
                  [`${mySide}ClientId`]: clientId,
                  [`${mySide}Joined`]: true,
                });
              } catch (err) {
                if (err.code === "permission-denied") {
                  console.error("Permission denied updating match join status");
                  // Continue anyway - the match can still work
                } else {
                  console.error("Error updating match join status", err);
                }
              }
            }

            // Handle veto phase (only higher seed sees quiz initially)
            if (match.status === "waiting_for_veto") {
              if (isHigherSeed && oppJoined) {
                // Show veto UI to higher seed
                showPlayoffVetoUI(matchRef, match, myAlias);
              } else if (!isHigherSeed) {
                // Lower seed waits
                showPlayoffWaitingForVeto(match);
              }
            }

            // Handle active match (after veto decision)
            if (match.status === "active") {
              showPlayoffActiveMatch(matchRef, match, myAlias, mySide);
            }

            // Handle completed match
            if (match.status === "completed") {
              showPlayoffMatchResult(match, myAlias);

              // If there's a winner, check if we need to create next round match
              if (match.winnerAlias) {
                await advanceWinnerToNextRound(db, seriesDoc, match);
              }
            }
          },
          (err) => {
            // Error handler for the listener
            if (err.code === "permission-denied") {
              console.error("Permission denied listening to playoff match");
              playoffJoinStatus.textContent =
                "Permission denied. Check Firestore rules.";
            } else {
              console.error("Error listening to playoff match", err);
              playoffJoinStatus.textContent = "Error loading match.";
            }
          }
        );

        // Store match data for score submission
        playoffMyMatchData = {
          matchRef: matchRef,
          myAlias: myAlias,
          seriesDoc: seriesDoc,
        };
      }

      /**
       * Show veto UI to higher seed
       */
      function showPlayoffVetoUI(matchRef, match, myAlias) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.add("d-none");
        h2hResultCard.classList.add("d-none");

        h2hYouName.textContent = match.higherDisplayName;
        h2hYouAlias.textContent = match.higherAlias;
        h2hOppName.textContent = match.lowerDisplayName;
        h2hOppAlias.textContent = match.lowerAlias;
        h2hQuizLink.href = match.quizUrl;
        h2hQuizLink.textContent = match.quizUrl;

        if (h2hVetoBtn && !match.vetoDecisionMade) {
          h2hVetoBtn.classList.remove("d-none");
          h2hVetoBtn.disabled = false;
          h2hVetoBtn.textContent = "Veto this quiz";

          // Add accept button
          let acceptBtn = document.getElementById("h2h-accept-btn");
          if (!acceptBtn) {
            acceptBtn = document.createElement("button");
            acceptBtn.id = "h2h-accept-btn";
            acceptBtn.className = "btn btn-success btn-sm ms-2";
            acceptBtn.textContent = "Accept this quiz";
            h2hVetoBtn.parentElement.appendChild(acceptBtn);
          }
          acceptBtn.classList.remove("d-none");
          acceptBtn.disabled = false;

          // Veto handler
          h2hVetoBtn.onclick = async (e) => {
            e.preventDefault();
            h2hVetoBtn.disabled = true;
            acceptBtn.disabled = true;

            try {
              const newQuizUrl = await getRandomPlayoffQuizUrl(db);
              await updateDoc(matchRef, {
                quizUrl: newQuizUrl,
                vetoUsed: true,
                vetoDecisionMade: true,
                status: "active",
              });
              playoffJoinStatus.textContent = "Veto used! New quiz assigned.";
            } catch (err) {
              console.error("Error using veto", err);
              h2hVetoBtn.disabled = false;
              acceptBtn.disabled = false;
            }
          };

          // Accept handler
          acceptBtn.onclick = async (e) => {
            e.preventDefault();
            h2hVetoBtn.disabled = true;
            acceptBtn.disabled = true;

            try {
              await updateDoc(matchRef, {
                vetoDecisionMade: true,
                status: "active",
              });
              playoffJoinStatus.textContent = "Quiz accepted!";
            } catch (err) {
              console.error("Error accepting quiz", err);
              h2hVetoBtn.disabled = false;
              acceptBtn.disabled = false;
            }
          };
        }

        playoffJoinStatus.textContent =
          "Review the quiz and decide whether to veto or accept.";
      }

      /**
       * Show waiting message to lower seed during veto phase
       */
      function showPlayoffWaitingForVeto(match) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.add("d-none");
        h2hResultCard.classList.add("d-none");

        h2hYouName.textContent = match.lowerDisplayName;
        h2hYouAlias.textContent = match.lowerAlias;
        h2hOppName.textContent = match.higherDisplayName;
        h2hOppAlias.textContent = match.higherAlias;
        h2hQuizLink.textContent = "Waiting for opponent to review quiz...";
        h2hQuizLink.removeAttribute("href");

        if (h2hVetoBtn) h2hVetoBtn.classList.add("d-none");
        const acceptBtn = document.getElementById("h2h-accept-btn");
        if (acceptBtn) acceptBtn.classList.add("d-none");

        playoffJoinStatus.textContent =
          "Waiting for higher seed to make veto decision...";
      }

      /**
       * Show active match (after veto decision)
       */
      function showPlayoffActiveMatch(matchRef, match, myAlias, mySide) {
        h2hMatchCard.classList.remove("d-none");
        h2hScoreCard.classList.remove("d-none");
        h2hResultCard.classList.add("d-none");

        const isHigher = mySide === "higher";

        h2hYouName.textContent = isHigher
          ? match.higherDisplayName
          : match.lowerDisplayName;
        h2hYouAlias.textContent = isHigher
          ? match.higherAlias
          : match.lowerAlias;
        h2hOppName.textContent = isHigher
          ? match.lowerDisplayName
          : match.higherDisplayName;
        h2hOppAlias.textContent = isHigher
          ? match.lowerAlias
          : match.higherAlias;
        h2hQuizLink.href = match.quizUrl;
        h2hQuizLink.textContent = match.quizUrl;

        // Hide veto buttons
        if (h2hVetoBtn) h2hVetoBtn.classList.add("d-none");
        const acceptBtn = document.getElementById("h2h-accept-btn");
        if (acceptBtn) acceptBtn.classList.add("d-none");

        // Enable score submission
        const myScore = match[`${mySide}Score`];
        if (myScore) {
          h2hScoreInput.value = myScore.rawScore;
          h2hTimeInput.value = formatSecondsAsMMSS(myScore.timeLeftSeconds);
          h2hScoreInput.disabled = true;
          h2hTimeInput.disabled = true;
          document.getElementById("h2h-score-submit-btn").disabled = true;
          h2hScoreStatus.textContent =
            "Score submitted. Waiting for opponent...";
        } else {
          h2hScoreInput.disabled = false;
          h2hTimeInput.disabled = false;
          h2hScoreInput.value = "";
          h2hTimeInput.value = "";
          document.getElementById("h2h-score-submit-btn").disabled = false;
          h2hScoreStatus.textContent = "Play the quiz and submit your score.";
        }

        playoffJoinStatus.textContent = match.vetoUsed
          ? "Veto was used. Quiz is now active!"
          : "Quiz accepted! Take the quiz and submit your score.";
      }

      /**
       * Show match result
       */
      function showPlayoffMatchResult(match, myAlias) {
        h2hResultCard.classList.remove("d-none");

        const isWinner = match.winnerAlias === myAlias;
        const isHigher = match.higherAlias === myAlias;
        const mySide = isHigher ? "higher" : "lower";
        const oppSide = isHigher ? "lower" : "higher";

        const myScore = match[`${mySide}Score`];
        const oppScore = match[`${oppSide}Score`];

        let summary;
        if (isWinner) {
          summary = `ðŸŽ‰ You won and advance to the next round!`;
        } else {
          summary = `You lost. Better luck next time!`;
        }

        h2hResultSummary.textContent = summary;

        const detailLines = [];
        if (myScore) {
          detailLines.push(
            `Your score: ${myScore.rawScore} (${Math.round(
              myScore.pct * 100
            )}%), time: ${formatSecondsAsMMSS(myScore.timeLeftSeconds)}`
          );
        }
        if (oppScore) {
          detailLines.push(
            `Opponent: ${oppScore.rawScore} (${Math.round(
              oppScore.pct * 100
            )}%), time: ${formatSecondsAsMMSS(oppScore.timeLeftSeconds)}`
          );
        }

        h2hResultDetail.innerHTML = "";
        detailLines.forEach((t) => {
          const li = document.createElement("li");
          li.textContent = t;
          h2hResultDetail.appendChild(li);
        });

        playoffJoinStatus.textContent = "Match completed!";
      }

      /**
       * Submit playoff score
       */
      if (h2hScoreForm) {
        h2hScoreForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          if (!playoffMyMatchData) {
            h2hScoreStatus.textContent = "No active playoff match.";
            return;
          }

          const { matchRef, myAlias } = playoffMyMatchData;

          const parsed = parseScoreString(h2hScoreInput.value);
          if (!parsed) {
            h2hScoreStatus.textContent =
              "Invalid score format. Use num/den (e.g., 7/9).";
            return;
          }

          const seconds = parseTimeString(h2hTimeInput.value);
          if (seconds === null) {
            h2hScoreStatus.textContent =
              "Invalid time format. Use mm:ss (e.g., 01:23).";
            return;
          }

          const scoreObj = {
            ...parsed,
            timeLeftSeconds: seconds,
            submittedAt: serverTimestamp(),
          };

          try {
            h2hScoreStatus.textContent = "Submitting score...";

            // Determine which side I am
            const matchSnap = await getDoc(matchRef);
            if (!matchSnap.exists()) {
              h2hScoreStatus.textContent = "Match not found.";
              return;
            }

            const match = matchSnap.data();
            const isHigher = match.higherAlias === myAlias;
            const mySide = isHigher ? "higher" : "lower";

            await updateDoc(matchRef, {
              [`${mySide}Score`]: scoreObj,
            });

            h2hScoreInput.disabled = true;
            h2hTimeInput.disabled = true;
            document.getElementById("h2h-score-submit-btn").disabled = true;
            h2hScoreStatus.textContent = "Score submitted!";

            // Try to resolve match
            await resolvePlayoffMatch(db, matchRef);
          } catch (err) {
            console.error("Error submitting playoff score", err);
            h2hScoreStatus.textContent = "Error submitting score.";
          }
        });
      }

      /**
       * Resolve playoff match when both scores are in
       */
      async function resolvePlayoffMatch(db, matchRef) {
        const matchSnap = await getDoc(matchRef);
        if (!matchSnap.exists()) return;

        const match = matchSnap.data();
        const higherScore = match.higherScore;
        const lowerScore = match.lowerScore;

        // Need both scores
        if (!higherScore || !lowerScore) return;

        // Already resolved
        if (match.status === "completed") return;

        // Determine winner
        let winnerAlias = null;

        const higherPct = higherScore.pct || 0;
        const lowerPct = lowerScore.pct || 0;

        if (higherPct > lowerPct) {
          winnerAlias = match.higherAlias;
        } else if (lowerPct > higherPct) {
          winnerAlias = match.lowerAlias;
        } else {
          // Tie on percentage, use time
          const higherTime = higherScore.timeLeftSeconds || 0;
          const lowerTime = lowerScore.timeLeftSeconds || 0;

          if (higherTime > lowerTime) {
            winnerAlias = match.higherAlias;
          } else if (lowerTime > higherTime) {
            winnerAlias = match.lowerAlias;
          } else {
            // Still tied - higher seed wins
            winnerAlias = match.higherAlias;
          }
        }

        // Update match
        await updateDoc(matchRef, {
          status: "completed",
          winnerAlias: winnerAlias,
          completedAt: serverTimestamp(),
        });

        // Update series
        await updateDoc(doc(collection(db, "playoffSeries"), match.seriesId), {
          status: "completed",
          winnerAlias: winnerAlias,
        });
      }

      /**
       * Advance winner to next round - creates or updates the next round match
       */
      async function advanceWinnerToNextRound(db, seriesDoc, matchResult) {
        const series = seriesDoc.data();
        const currentRound = series.round || 1;
        const currentMatchIndex = series.matchIndex || 0;
        const winnerAlias = matchResult.winnerAlias;
        const winnerDisplayName = matchResult.winnerDisplayName || winnerAlias;

        // Get winner's seed
        const currentSeeds = series.seeds || [null, null];
        const aliases = series.aliases || [];
        const winnerIndex = aliases.indexOf(winnerAlias);
        const winnerSeed = winnerIndex >= 0 ? currentSeeds[winnerIndex] : null;

        console.log(
          `ðŸ† Winner ${winnerAlias} (seed ${winnerSeed}) from Round ${currentRound}, Match ${currentMatchIndex}`
        );

        // Calculate next round parameters
        const nextRound = currentRound + 1;
        const nextMatchIndex = Math.floor(currentMatchIndex / 2);

        // Determine which position in the next match (top or bottom)
        // Even matchIndex (0, 2, 4...) goes to position 0, odd (1, 3, 5...) goes to position 1
        const positionInNextMatch = currentMatchIndex % 2;

        console.log(
          `âž¡ï¸ Should advance to Round ${nextRound}, Match ${nextMatchIndex}, Position ${positionInNextMatch}`
        );

        // Find if next round match already exists
        const nextSeriesRef = collection(db, "playoffSeries");
        const q = query(
          nextSeriesRef,
          where("round", "==", nextRound),
          where("matchIndex", "==", nextMatchIndex)
        );

        try {
          const snap = await getDocs(q);

          if (snap.empty) {
            // Create new next round match
            console.log(
              `âœ¨ Creating new match for Round ${nextRound}, Match ${nextMatchIndex}`
            );

            const newMatchRef = doc(nextSeriesRef);

            const newAliases = ["TBD", "TBD"];
            const newSeeds = [null, null];

            newAliases[positionInNextMatch] = winnerAlias;
            newSeeds[positionInNextMatch] = winnerSeed;

            await setDoc(newMatchRef, {
              round: nextRound,
              matchIndex: nextMatchIndex,
              aliases: newAliases,
              seeds: newSeeds,
              status: "pending",
              winnerAlias: null,
              createdAt: serverTimestamp(),
            });

            console.log(`âœ… Created: ${newAliases[0]} vs ${newAliases[1]}`);
          } else {
            // Update existing next round match
            const nextMatchDoc = snap.docs[0];
            const nextMatch = nextMatchDoc.data();
            const currentAliases = nextMatch.aliases || ["TBD", "TBD"];
            const currentSeeds = nextMatch.seeds || [null, null];

            console.log(
              `ðŸ“ Updating existing match: ${currentAliases[0]} vs ${currentAliases[1]}`
            );

            const updatedAliases = [...currentAliases];
            const updatedSeeds = [...currentSeeds];

            updatedAliases[positionInNextMatch] = winnerAlias;
            updatedSeeds[positionInNextMatch] = winnerSeed;

            const updates = {
              aliases: updatedAliases,
              seeds: updatedSeeds,
            };

            // If both slots are now filled, mark as ready to play
            if (updatedAliases[0] !== "TBD" && updatedAliases[1] !== "TBD") {
              updates.status = "pending";
              console.log(
                `ðŸŽ® Match is now ready: ${updatedAliases[0]} vs ${updatedAliases[1]}`
              );
            }

            await updateDoc(nextMatchDoc.ref, updates);

            console.log(
              `âœ… Updated: ${updatedAliases[0]} vs ${updatedAliases[1]}`
            );
          }
        } catch (err) {
          console.error("âŒ Error advancing winner to next round:", err);
          throw err;
        }
      }

      // ============================================================================
      // DYNAMIC PLAYOFF BRACKET VISUALIZATION
      // ============================================================================

      const playoffsBracketContainer =
        document.getElementById("playoffs-bracket");
      let bracketUnsubscribe = null;

      /**
       * Start listening to playoff series and render bracket dynamically
       */
      function startBracketListener() {
        if (bracketUnsubscribe) {
          bracketUnsubscribe();
        }

        const seriesRef = collection(db, "playoffSeries");
        bracketUnsubscribe = onSnapshot(seriesRef, (snap) => {
          const allSeries = [];
          snap.forEach((doc) => {
            allSeries.push({ id: doc.id, ...doc.data() });
          });
          renderBracket(allSeries);
        });
      }

      /**
       * Render the playoff bracket using React
       */
      async function renderBracket(allSeries) {
        if (!playoffsBracketContainer) return;

        if (allSeries.length === 0) {
          playoffsBracketContainer.innerHTML =
            '<p class="text-center text-muted">No playoff matches yet.</p>';
          return;
        }

        // Fetch all display names once
        const allAliases = new Set();
        allSeries.forEach((series) => {
          const aliases = series.aliases || [];
          aliases.forEach((alias) => {
            if (alias !== "TBD") allAliases.add(alias);
          });
        });

        const displayNames = {};

        // Fetch display names from points collection
        for (const alias of allAliases) {
          try {
            const pointsDoc = await getDoc(
              doc(collection(db, "points"), alias)
            );
            if (pointsDoc.exists()) {
              const data = pointsDoc.data();
              displayNames[alias] = data.displayName || alias;
            } else {
              displayNames[alias] = alias;
            }
          } catch (err) {
            console.error(`Error fetching data for ${alias}`, err);
            displayNames[alias] = alias;
          }
        }

        // Render with React
        const root = ReactDOM.createRoot(playoffsBracketContainer);
        root.render(
          React.createElement(PlayoffBracket, {
            matches: allSeries,
            displayNames: displayNames,
            darkMode: true,
          })
        );
      }

      // ============== REACT PLAYOFF BRACKET COMPONENT ==============

      function PlayoffBracket({ matches, displayNames, darkMode }) {
        const rounds = {};
        let maxRound = 0;

        matches.forEach((match) => {
          const round = match.round || 1;
          if (!rounds[round]) rounds[round] = [];
          rounds[round].push(match);
          if (round > maxRound) maxRound = round;
        });

        const sortedRoundNumbers = Object.keys(rounds)
          .map(Number)
          .sort((a, b) => a - b);

        sortedRoundNumbers.forEach((roundNum) => {
          rounds[roundNum].sort(
            (a, b) => (a.matchIndex || 0) - (b.matchIndex || 0)
          );
        });

        // Calculate total rounds based on first round match count
        // 16 matches in R1 = 32 teams = 5 rounds (R32, S16, E8, F4, Championship)
        // 8 matches in R1 = 16 teams = 4 rounds (S16, E8, F4, Championship)
        // 4 matches in R1 = 8 teams = 3 rounds (E8, F4, Championship)
        const firstRoundMatches = rounds[1] ? rounds[1].length : 0;

        // Calculate total rounds: log2(teams) where teams = firstRoundMatches * 2
        // 16 matches = 32 teams = log2(32) = 5 rounds
        const totalExpectedRounds =
          firstRoundMatches > 0 ? Math.log2(firstRoundMatches * 2) : maxRound;

        const getRoundName = (roundNum) => {
          // Calculate rounds remaining based on TOTAL expected rounds
          const roundsRemaining = totalExpectedRounds - roundNum;
          if (roundsRemaining === 0) return "Championship";
          if (roundsRemaining === 1) return "Final Four";
          if (roundsRemaining === 2) return "Elite Eight";
          if (roundsRemaining === 3) return "Sweet Sixteen";
          if (roundsRemaining === 4) return "Round of 32";
          if (roundsRemaining === 5) return "Round of 64";
          return `Round ${roundNum}`;
        };

        // Calculate the height of a single match card
        const MATCH_HEIGHT = 70; // Height of one match card in pixels
        const MATCH_GAP = 10; // Gap between matches in the same round

        const theme = {
          bg: darkMode ? "#1a1d23" : "#ffffff",
          cardBg: darkMode ? "#282c34" : "#f8f9fa",
          border: darkMode ? "#3d4250" : "#dee2e6",
          text: darkMode ? "#e9ecef" : "#212529",
          textMuted: darkMode ? "#8b949e" : "#6c757d",
          winner: darkMode ? "#3fb97a" : "#198754",
          winnerBg: darkMode ? "rgba(63, 185, 122, 0.2)" : "#d1e7dd",
          active: darkMode ? "#4493f8" : "#0d6efd",
          connector: darkMode ? "#3d4250" : "#dee2e6",
        };

        if (matches.length === 0) {
          return React.createElement(
            "div",
            {
              style: {
                padding: "40px",
                textAlign: "center",
                color: theme.textMuted,
                backgroundColor: theme.bg,
                borderRadius: "12px",
              },
            },
            "No playoff matches yet."
          );
        }

        // Generate all rounds including future ones with TBD placeholders
        const allRounds = [];
        for (let r = 1; r <= totalExpectedRounds; r++) {
          if (rounds[r]) {
            allRounds.push({ roundNum: r, matches: rounds[r] });
          } else {
            // Generate placeholder matches for this round
            // Number of matches = firstRoundMatches / 2^(r-1)
            const matchCount = Math.max(
              1,
              Math.floor(firstRoundMatches / Math.pow(2, r - 1))
            );
            const placeholders = [];
            for (let m = 0; m < matchCount; m++) {
              placeholders.push({
                id: `placeholder-${r}-${m}`,
                round: r,
                matchIndex: m,
                aliases: ["TBD", "TBD"],
                seeds: [null, null],
                status: "pending",
                winnerAlias: null,
              });
            }
            allRounds.push({ roundNum: r, matches: placeholders });
          }
        }

        return React.createElement(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              overflowX: "auto",
              padding: "20px",
              backgroundColor: theme.bg,
              borderRadius: "12px",
              alignItems: "flex-start",
            },
          },
          allRounds.map((roundData, roundIndex) => {
            const roundNum = roundData.roundNum;
            const roundMatches = roundData.matches;

            // Calculate spacing for proper bracket alignment
            // Each round should have matches centered between the two matches that feed into it
            const matchesInRound = roundMatches.length;
            const spacingMultiplier = Math.pow(2, roundIndex);
            const totalMatchHeight = MATCH_HEIGHT + MATCH_GAP;

            // Gap between matches in this round
            const gapBetweenMatches =
              totalMatchHeight * spacingMultiplier - MATCH_HEIGHT;

            // Initial offset to center this round's matches with the previous round
            const initialOffset =
              (totalMatchHeight * (spacingMultiplier - 1)) / 2;

            return React.createElement(
              "div",
              {
                key: roundNum,
                style: {
                  display: "flex",
                  flexDirection: "column",
                  minWidth: "180px",
                  flexShrink: 0,
                  marginRight: "20px",
                },
              },
              [
                // Round Title
                React.createElement(
                  "div",
                  {
                    key: "title",
                    style: {
                      textAlign: "center",
                      fontWeight: "600",
                      fontSize: "0.75rem",
                      textTransform: "uppercase",
                      letterSpacing: "0.5px",
                      color: theme.winner,
                      marginBottom: "12px",
                      padding: "6px",
                    },
                  },
                  getRoundName(roundNum)
                ),

                // Matches Container
                React.createElement(
                  "div",
                  {
                    key: "matches",
                    style: {
                      display: "flex",
                      flexDirection: "column",
                      paddingTop: `${initialOffset}px`,
                    },
                  },
                  roundMatches.map((match, matchIndex) =>
                    React.createElement(
                      "div",
                      {
                        key: match.id || `${roundNum}-${matchIndex}`,
                        style: {
                          marginBottom:
                            matchIndex < roundMatches.length - 1
                              ? `${gapBetweenMatches}px`
                              : "0",
                        },
                      },
                      React.createElement(MatchCard, {
                        match: match,
                        displayNames: displayNames,
                        theme: theme,
                        showConnector: roundIndex < allRounds.length - 1,
                      })
                    )
                  )
                ),
              ]
            );
          })
        );
      }

      function MatchCard({ match, displayNames, theme, showConnector }) {
        const aliases = match.aliases || [];
        const seeds = match.seeds || [null, null];
        const winner = match.winnerAlias;
        const isCompleted = match.status === "completed";
        const isActive = match.status === "active";

        const player1Alias = aliases[0] || "TBD";
        const player2Alias = aliases[1] || "TBD";
        const player1Name =
          player1Alias === "TBD"
            ? "TBD"
            : displayNames[player1Alias] || player1Alias;
        const player2Name =
          player2Alias === "TBD"
            ? "TBD"
            : displayNames[player2Alias] || player2Alias;

        return React.createElement(
          "div",
          {
            style: {
              backgroundColor: theme.cardBg,
              border: `2px solid ${
                isActive
                  ? theme.active
                  : isCompleted
                  ? theme.winner
                  : theme.border
              }`,
              borderRadius: "6px",
              padding: "2px",
              position: "relative",
              boxShadow: isActive ? `0 0 12px ${theme.active}40` : "none",
              height: "66px", // Fixed height for consistent bracket alignment
              boxSizing: "border-box",
            },
          },
          [
            React.createElement(PlayerRow, {
              key: "p1",
              name: player1Name,
              seed: seeds[0],
              isWinner: winner === player1Alias,
              isLoser:
                winner && winner !== player1Alias && player1Alias !== "TBD",
              isTBD: player1Alias === "TBD",
              theme: theme,
            }),
            React.createElement(PlayerRow, {
              key: "p2",
              name: player2Name,
              seed: seeds[1],
              isWinner: winner === player2Alias,
              isLoser:
                winner && winner !== player2Alias && player2Alias !== "TBD",
              isTBD: player2Alias === "TBD",
              theme: theme,
            }),
            // Horizontal connector line to next round
            showConnector &&
              React.createElement("div", {
                key: "connector",
                style: {
                  position: "absolute",
                  right: "-21px",
                  top: "50%",
                  width: "20px",
                  height: "2px",
                  backgroundColor: theme.connector,
                  transform: "translateY(-50%)",
                },
              }),
          ]
        );
      }

      function PlayerRow({ name, seed, isWinner, isLoser, isTBD, theme }) {
        return React.createElement(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              padding: "6px 8px",
              margin: "1px",
              borderRadius: "3px",
              fontSize: "0.8rem",
              backgroundColor: isWinner ? theme.winnerBg : "transparent",
              color: isWinner
                ? theme.winner
                : isLoser
                ? theme.textMuted
                : isTBD
                ? theme.textMuted
                : theme.text,
              fontWeight: isWinner ? "600" : "400",
              fontStyle: isTBD ? "italic" : "normal",
              opacity: isLoser ? 0.5 : 1,
              height: "28px",
              boxSizing: "border-box",
            },
          },
          [
            React.createElement(
              "span",
              {
                key: "info",
                style: { display: "flex", alignItems: "center", gap: "6px" },
              },
              [
                seed &&
                  React.createElement(
                    "span",
                    {
                      key: "seed",
                      style: {
                        fontSize: "0.7rem",
                        opacity: 0.7,
                        minWidth: "16px",
                        fontWeight: "600",
                      },
                    },
                    seed
                  ),
                React.createElement(
                  "span",
                  {
                    key: "name",
                    style: {
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      whiteSpace: "nowrap",
                      maxWidth: "120px",
                    },
                  },
                  name
                ),
              ]
            ),
            isWinner &&
              React.createElement(
                "span",
                {
                  key: "check",
                  style: { color: theme.winner },
                },
                "âœ“"
              ),
          ]
        );
      }

      // Start the bracket listener when the playoffs tab is shown
      const playoffsTab = document.querySelector(
        '[data-bs-target="#tab-playoffs"]'
      );
      if (playoffsTab) {
        playoffsTab.addEventListener("shown.bs.tab", () => {
          startBracketListener();
        });
      }

      // Also start on page load if playoffs are finalized
      onSnapshot(playoffsConfigRef, (snap) => {
        const data = snap.exists() ? snap.data() : {};
        __playoffsFinalized = !!data.finalized;
        updatePlayoffsUIFromFlag();

        // Start bracket listener if playoffs are active
        if (__playoffsFinalized) {
          startBracketListener();
        }
      });

      // ============================================================================
      // ADMIN: Manual Playoff Result Entry
      // ============================================================================

      const manualPlayoffForm = document.getElementById(
        "manual-playoff-result-form"
      );
      const manualPlayoffStatus = document.getElementById(
        "manual-playoff-status"
      );
      const playoffMatchesBody = document.getElementById(
        "playoff-matches-body"
      );

      // Load and display all playoff series
      async function loadPlayoffMatches() {
        if (!playoffMatchesBody) return;

        const seriesRef = collection(db, "playoffSeries");
        const q = query(
          seriesRef,
          orderBy("round", "asc"),
          orderBy("matchIndex", "asc")
        );
        const snap = await getDocs(q);

        playoffMatchesBody.innerHTML = "";

        if (snap.empty) {
          playoffMatchesBody.innerHTML =
            '<tr><td colspan="7" class="text-center">No playoff series found</td></tr>';
          return;
        }

        snap.forEach((docSnap) => {
          const series = docSnap.data();
          const tr = document.createElement("tr");

          const aliases = series.aliases || [];
          const player1 = aliases[0] || "TBD";
          const player2 = aliases[1] || "TBD";
          const status = series.status || "pending";
          const winner = series.winnerAlias || "-";

          tr.innerHTML = `
      <td>${series.round || "-"}</td>
      <td>${series.matchIndex || "0"}</td>
      <td>${player1}</td>
      <td>${player2}</td>
      <td>
        <span class="badge ${
          status === "completed"
            ? "bg-success"
            : status === "active"
            ? "bg-primary"
            : "bg-secondary"
        }">
          ${status}
        </span>
      </td>
      <td>${winner}</td>
      <td>
        ${
          status !== "completed"
            ? `
          <button class="btn btn-sm btn-outline-primary set-winner-btn" 
                  data-series-id="${docSnap.id}"
                  data-player1="${player1}"
                  data-player2="${player2}">
            Set Winner
          </button>
        `
            : "-"
        }
      </td>
    `;

          playoffMatchesBody.appendChild(tr);
        });

        // Add click handlers to "Set Winner" buttons
        document.querySelectorAll(".set-winner-btn").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            const seriesId = e.target.dataset.seriesId;
            const player1 = e.target.dataset.player1;
            const player2 = e.target.dataset.player2;

            const winner = prompt(
              `Who won this match?\n\n1. ${player1}\n2. ${player2}\n\nEnter the winner's alias:`
            );
            if (!winner) return;

            const winnerAlias = winner.trim().toLowerCase();

            try {
              await setPlayoffWinner(seriesId, winnerAlias);
              alert("Winner set successfully!");
              loadPlayoffMatches(); // Reload table
            } catch (err) {
              console.error("Error setting winner", err);
              alert("Error: " + err.message);
            }
          });
        });
      }

      // Manual form submission
      if (manualPlayoffForm) {
        manualPlayoffForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          const round = parseInt(
            document.getElementById("playoff-round").value,
            10
          );
          const matchIndex = parseInt(
            document.getElementById("playoff-match-index").value,
            10
          );
          const winnerAlias = document
            .getElementById("playoff-winner-alias")
            .value.trim()
            .toLowerCase();

          if (!winnerAlias) {
            manualPlayoffStatus.textContent = "Please enter a winner alias.";
            return;
          }

          try {
            manualPlayoffStatus.textContent = "Finding match...";

            // Find the series by round and matchIndex
            const seriesRef = collection(db, "playoffSeries");
            const q = query(
              seriesRef,
              where("round", "==", round),
              where("matchIndex", "==", matchIndex)
            );
            const snap = await getDocs(q);

            if (snap.empty) {
              manualPlayoffStatus.textContent = `No match found for Round ${round}, Match ${matchIndex}.`;
              return;
            }

            const seriesDoc = snap.docs[0];
            const series = seriesDoc.data();
            const aliases = series.aliases || [];

            if (!aliases.includes(winnerAlias)) {
              manualPlayoffStatus.textContent = `Winner "${winnerAlias}" is not in this matchup. Players: ${aliases.join(
                ", "
              )}`;
              return;
            }

            manualPlayoffStatus.textContent = "Setting winner...";
            await setPlayoffWinner(seriesDoc.id, winnerAlias);

            manualPlayoffStatus.textContent = `âœ… Winner set: ${winnerAlias} advances from Round ${round}, Match ${matchIndex}`;
            manualPlayoffForm.reset();

            // Reload the table
            loadPlayoffMatches();
          } catch (err) {
            console.error("Error setting playoff winner", err);
            manualPlayoffStatus.textContent = "Error: " + err.message;
          }
        });
      }

      /**
       * Set the winner for a playoff series and advance them to next round
       */
      async function setPlayoffWinner(seriesId, winnerAlias) {
        console.log(
          `ðŸŽ¯ setPlayoffWinner called with seriesId=${seriesId}, winnerAlias=${winnerAlias}`
        );

        const seriesRef = doc(collection(db, "playoffSeries"), seriesId);
        const seriesSnap = await getDoc(seriesRef);

        if (!seriesSnap.exists()) {
          throw new Error("Series not found");
        }

        const series = seriesSnap.data();
        console.log(`ðŸ“‹ Series data:`, series);

        const aliases = series.aliases || [];

        if (!aliases.includes(winnerAlias)) {
          throw new Error(
            `Winner "${winnerAlias}" is not in this matchup. Players: ${aliases.join(
              ", "
            )}`
          );
        }

        // Validate that round and matchIndex exist
        if (series.round === undefined || series.matchIndex === undefined) {
          console.error("âŒ Series is missing round or matchIndex!", series);
          throw new Error(
            `Series is missing round (${series.round}) or matchIndex (${series.matchIndex})`
          );
        }

        // Get winner's display name from points collection
        const winnerPointsDoc = await getDoc(
          doc(collection(db, "points"), winnerAlias)
        );
        const winnerDisplayName = winnerPointsDoc.exists()
          ? winnerPointsDoc.data().displayName || winnerAlias
          : winnerAlias;

        console.log(
          `ðŸ“ Updating series ${seriesId} with winner ${winnerAlias}`
        );

        // Update series
        await updateDoc(seriesRef, {
          status: "completed",
          winnerAlias: winnerAlias,
          winnerDisplayName: winnerDisplayName,
          completedAt: serverTimestamp(),
        });

        // If there's a match document, update it too
        const matchRef = doc(collection(db, "playoffMatches"), seriesId);
        const matchSnap = await getDoc(matchRef);

        if (matchSnap.exists()) {
          await updateDoc(matchRef, {
            status: "completed",
            winnerAlias: winnerAlias,
            completedAt: serverTimestamp(),
          });
        }

        // Advance winner to next round
        console.log(
          `ðŸš€ Advancing winner ${winnerAlias} from Round ${series.round}, Match ${series.matchIndex}`
        );

        try {
          await advanceWinnerToNextRound(db, seriesSnap, {
            winnerAlias,
            winnerDisplayName,
            round: series.round,
            matchIndex: series.matchIndex,
          });
          console.log(`âœ… Successfully advanced winner to next round`);
        } catch (advanceErr) {
          console.error(`âŒ Error in advanceWinnerToNextRound:`, advanceErr);
          throw advanceErr;
        }
      }

      // Load playoff matches when admin tab is shown (only if user is admin)
      document
        .getElementById("admin-tab-btn")
        ?.addEventListener("click", () => {
          if (window.__isAdmin) {
            setTimeout(() => loadPlayoffMatches(), 100);
          }
        });

      // Also load on page load if admin
      window.addEventListener("load", () => {
        if (window.__isAdmin) {
          setTimeout(() => loadPlayoffMatches(), 500);
        }
      });

      /**
       * Get random playoff quiz URL
       */
      let playoffRecentQuizUrls = [];

      async function getRandomPlayoffQuizUrl(db) {
        const ref = collection(db, "playoffQuizzes");
        const snap = await getDocs(ref);

        const urls = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (d && d.url) urls.push(d.url);
        });

        if (!urls.length) {
          throw new Error("No playoff quizzes available");
        }

        // Avoid recent repeats
        let choice = null;
        for (let tries = 0; tries < 5; tries++) {
          const idx = Math.floor(Math.random() * urls.length);
          const candidate = urls[idx];
          if (!playoffRecentQuizUrls.includes(candidate)) {
            choice = candidate;
            break;
          }
        }
        if (!choice) {
          const idx = Math.floor(Math.random() * urls.length);
          choice = urls[idx];
        }

        playoffRecentQuizUrls.push(choice);
        if (playoffRecentQuizUrls.length > 10) {
          playoffRecentQuizUrls.shift();
        }

        return choice;
      }

      async function getRandomQuizUrl(db) {
        const quizzesRef = collection(db, "quizzes");
        const snap = await getDocs(quizzesRef);

        const urls = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          if (d && d.url) urls.push(d.url);
        });

        if (!urls.length) {
          throw new Error("No quizzes available");
        }

        // avoid recent repeats on this device
        let choice = null;
        for (let tries = 0; tries < 5; tries++) {
          const idx = Math.floor(Math.random() * urls.length);
          const candidate = urls[idx];
          if (!h2hRecentQuizUrls.includes(candidate)) {
            choice = candidate;
            break;
          }
        }
        if (!choice) {
          const idx = Math.floor(Math.random() * urls.length);
          choice = urls[idx];
        }

        h2hRecentQuizUrls.push(choice);
        if (h2hRecentQuizUrls.length > 10) {
          h2hRecentQuizUrls.shift();
        }

        return choice;
      }

      // ============================================================================
      // ADMIN: Initialize Playoff Bracket with Seeds
      // ============================================================================

      /**
       * Add seeds to existing playoff series based on points standings
       */
      async function addSeedsToPlayoffSeries() {
        try {
          // Get all players from points collection, sorted by points
          const pointsRef = collection(db, "points");
          const pointsSnap = await getDocs(
            query(pointsRef, orderBy("points", "desc"))
          );

          const seedMap = {};
          let seed = 1;
          pointsSnap.forEach((doc) => {
            seedMap[doc.id] = seed;
            seed++;
          });

          // Update all playoff series with seeds
          const seriesRef = collection(db, "playoffSeries");
          const seriesSnap = await getDocs(seriesRef);

          const batch = writeBatch(db);
          let updateCount = 0;

          seriesSnap.forEach((doc) => {
            const series = doc.data();
            const aliases = series.aliases || [];

            const player1Seed =
              aliases[0] !== "TBD" ? seedMap[aliases[0]] : null;
            const player2Seed =
              aliases[1] !== "TBD" ? seedMap[aliases[1]] : null;

            if (player1Seed || player2Seed) {
              batch.update(doc.ref, {
                seeds: [player1Seed, player2Seed],
              });
              updateCount++;
            }
          });

          if (updateCount > 0) {
            await batch.commit();
            console.log(`Updated ${updateCount} playoff series with seeds`);
            return `âœ… Added seeds to ${updateCount} matches`;
          } else {
            return "No matches needed seed updates";
          }
        } catch (err) {
          console.error("Error adding seeds", err);
          throw err;
        }
      }

      // Add button to admin panel to trigger seed setup
      const addSeedsBtn = document.getElementById("add-seeds-btn");
      if (addSeedsBtn) {
        addSeedsBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "Add seeds to all playoff matches based on current standings?"
            )
          )
            return;

          try {
            addSeedsBtn.disabled = true;
            addSeedsBtn.textContent = "Adding seeds...";
            const result = await addSeedsToPlayoffSeries();
            alert(result);
            loadPlayoffMatches(); // Refresh the table
          } catch (err) {
            alert("Error: " + err.message);
          } finally {
            addSeedsBtn.disabled = false;
            addSeedsBtn.textContent = "Add Seeds to Bracket";
          }
        });
      }

      // Reset & Initialize Bracket button
      const resetBracketBtn = document.getElementById("reset-bracket-btn");
      if (resetBracketBtn) {
        resetBracketBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "âš ï¸ WARNING: This will DELETE all playoff data and create a fresh bracket!\n\n" +
                "This will:\n" +
                "â€¢ Delete ALL documents in playoffSeries\n" +
                "â€¢ Delete ALL documents in playoffMatches\n" +
                "â€¢ Create fresh Round of 32 matchups based on current standings\n\n" +
                "Are you sure you want to continue?"
            )
          )
            return;

          // Double confirm
          if (!confirm("Are you REALLY sure? This cannot be undone!")) return;

          try {
            resetBracketBtn.disabled = true;
            resetBracketBtn.textContent = "Resetting...";

            const statusDiv = document.getElementById(
              "playoffs-finalize-status"
            );
            if (statusDiv) statusDiv.textContent = "Deleting existing data...";

            // Step 1: Delete all playoffSeries documents
            console.log("ðŸ—‘ï¸ Step 1: Deleting playoffSeries...");
            const seriesRef = collection(db, "playoffSeries");
            let seriesSnap;
            try {
              seriesSnap = await getDocs(seriesRef);
              console.log(
                `  Found ${seriesSnap.docs.length} playoffSeries documents to delete`
              );
            } catch (readErr) {
              console.error("âŒ Failed to READ playoffSeries:", readErr);
              throw new Error("Cannot read playoffSeries: " + readErr.message);
            }

            let deletedSeries = 0;
            for (const docSnap of seriesSnap.docs) {
              try {
                await deleteDoc(docSnap.ref);
                deletedSeries++;
              } catch (delErr) {
                console.error(
                  `âŒ Failed to DELETE playoffSeries/${docSnap.id}:`,
                  delErr
                );
                throw new Error(
                  `Cannot delete playoffSeries/${docSnap.id}: ${delErr.message}`
                );
              }
            }
            console.log(`âœ… Deleted ${deletedSeries} playoffSeries documents`);

            // Step 2: Delete all playoffMatches documents
            console.log("ðŸ—‘ï¸ Step 2: Deleting playoffMatches...");
            const matchesRef = collection(db, "playoffMatches");
            let matchesSnap;
            try {
              matchesSnap = await getDocs(matchesRef);
              console.log(
                `  Found ${matchesSnap.docs.length} playoffMatches documents to delete`
              );
            } catch (readErr) {
              console.error("âŒ Failed to READ playoffMatches:", readErr);
              throw new Error("Cannot read playoffMatches: " + readErr.message);
            }

            let deletedMatches = 0;
            for (const docSnap of matchesSnap.docs) {
              try {
                await deleteDoc(docSnap.ref);
                deletedMatches++;
              } catch (delErr) {
                console.error(
                  `âŒ Failed to DELETE playoffMatches/${docSnap.id}:`,
                  delErr
                );
                throw new Error(
                  `Cannot delete playoffMatches/${docSnap.id}: ${delErr.message}`
                );
              }
            }
            console.log(
              `âœ… Deleted ${deletedMatches} playoffMatches documents`
            );

            if (statusDiv) statusDiv.textContent = "Creating fresh bracket...";

            // Step 3: Get current standings to seed the bracket
            console.log("ðŸ“Š Step 3: Fetching standings...");
            const pointsRef = collection(db, "points");
            let pointsSnap;
            try {
              pointsSnap = await getDocs(pointsRef);
            } catch (readErr) {
              console.error("âŒ Failed to READ points:", readErr);
              throw new Error("Cannot read points: " + readErr.message);
            }

            const players = [];
            pointsSnap.forEach((docSnap) => {
              const data = docSnap.data();
              // Log first few to see the data structure
              if (players.length < 5) {
                console.log(`  Player ${docSnap.id}:`, JSON.stringify(data));
              }
              players.push({
                alias: docSnap.id,
                displayName: data.displayName || docSnap.id,
                pts: data.pts || 0, // Using 'pts' field
              });
            });

            // Sort by points descending, then by displayName alphabetically for ties
            players.sort((a, b) => {
              if (b.pts !== a.pts) {
                return b.pts - a.pts; // Higher points first
              }
              // Same points - sort alphabetically by displayName
              return a.displayName
                .toLowerCase()
                .localeCompare(b.displayName.toLowerCase());
            });
            console.log(`ðŸ“‹ Found ${players.length} players total`);

            // Log the top 10 to verify sorting
            console.log("ðŸ† Top 10 by points:");
            players.slice(0, 10).forEach((p, i) => {
              console.log(
                `  ${i + 1}. ${p.displayName} (${p.alias}): ${p.pts} pts`
              );
            });

            // Create seeds (top 32, fill with BYE if needed)
            const seeds = [];
            for (let i = 0; i < 32; i++) {
              if (players[i]) {
                seeds.push({
                  seed: i + 1,
                  alias: players[i].alias,
                  displayName: players[i].displayName,
                  isBye: false,
                });
              } else {
                seeds.push({
                  seed: i + 1,
                  alias: `BYE_${i + 1}`,
                  displayName: "BYE",
                  isBye: true,
                });
              }
            }

            console.log("ðŸŒ± Seeds created:");
            seeds.slice(0, 10).forEach((s) => {
              console.log(
                `  #${s.seed}: ${s.displayName} (${s.alias})${
                  s.isBye ? " [BYE]" : ""
                }`
              );
            });

            // Standard bracket pairings for 32-team tournament
            // This ensures 1 plays 32, 2 plays 31, etc. in proper bracket order
            const bracketPairs = [
              [1, 32], // Match 0
              [16, 17], // Match 1
              [8, 25], // Match 2
              [9, 24], // Match 3
              [4, 29], // Match 4
              [13, 20], // Match 5
              [5, 28], // Match 6
              [12, 21], // Match 7
              [2, 31], // Match 8
              [15, 18], // Match 9
              [7, 26], // Match 10
              [10, 23], // Match 11
              [3, 30], // Match 12
              [14, 19], // Match 13
              [6, 27], // Match 14
              [11, 22], // Match 15
            ];

            // Create seed lookup map
            const seedMap = {};
            seeds.forEach((s) => {
              seedMap[s.seed] = s;
            });

            // Step 4: Create Round 1 (Round of 32) matchups
            console.log("ðŸ€ Creating Round of 32 matchups...");
            let createdMatches = 0;

            for (
              let matchIndex = 0;
              matchIndex < bracketPairs.length;
              matchIndex++
            ) {
              const [seed1, seed2] = bracketPairs[matchIndex];
              const player1 = seedMap[seed1];
              const player2 = seedMap[seed2];

              const matchData = {
                round: 1,
                matchIndex: matchIndex,
                aliases: [player1.alias, player2.alias],
                seeds: [seed1, seed2],
                displayNames: [player1.displayName, player2.displayName],
                status:
                  player1.isBye || player2.isBye ? "completed" : "pending",
                winnerAlias: null,
                createdAt: serverTimestamp(),
              };

              // If one player is a BYE, auto-advance the other
              if (player1.isBye && !player2.isBye) {
                matchData.winnerAlias = player2.alias;
                matchData.status = "completed";
              } else if (player2.isBye && !player1.isBye) {
                matchData.winnerAlias = player1.alias;
                matchData.status = "completed";
              }

              await addDoc(seriesRef, matchData);
              createdMatches++;
              console.log(
                `  âœ… Match ${matchIndex}: #${seed1} ${player1.displayName} vs #${seed2} ${player2.displayName}`
              );
            }

            console.log(`ðŸŽ‰ Created ${createdMatches} Round of 32 matchups!`);

            // Step 5: Auto-advance BYE winners to Round 2
            if (statusDiv) statusDiv.textContent = "Processing BYE advances...";

            // Re-fetch the series to get the document IDs
            const newSeriesSnap = await getDocs(seriesRef);
            for (const docSnap of newSeriesSnap.docs) {
              const data = docSnap.data();
              if (data.status === "completed" && data.winnerAlias) {
                console.log(
                  `ðŸš€ Auto-advancing BYE winner: ${data.winnerAlias}`
                );
                await advanceWinnerToNextRound(db, docSnap, {
                  winnerAlias: data.winnerAlias,
                  winnerDisplayName: data.displayNames
                    ? data.aliases[0] === data.winnerAlias
                      ? data.displayNames[0]
                      : data.displayNames[1]
                    : data.winnerAlias,
                });
              }
            }

            if (statusDiv) {
              statusDiv.textContent = `âœ… Bracket reset complete! Created ${createdMatches} Round of 32 matchups.`;
            }

            alert(
              `Bracket reset complete!\n\n` +
                `â€¢ Deleted ${deletedSeries} old series\n` +
                `â€¢ Deleted ${deletedMatches} old matches\n` +
                `â€¢ Created ${createdMatches} Round of 32 matchups\n\n` +
                `BYE winners have been auto-advanced to Round 2.`
            );

            // Refresh the admin table and bracket
            loadPlayoffMatches();
            startBracketListener();
          } catch (err) {
            console.error("Error resetting bracket:", err);
            alert("Error resetting bracket: " + err.message);
          } finally {
            resetBracketBtn.disabled = false;
            resetBracketBtn.textContent = "ðŸ”„ Reset & Initialize Bracket";
          }
        });
      }

      /**
       * Try to pair this user with a waiting opponent.
       * If someone is waiting, create match doc and mark both as matched.
       * If not, you just stay waiting until someone else joins.
       */
      async function tryHeadToHeadMatchmaking(db, myQueueRef, myData) {
        const queueRef = collection(db, "headtoheadQueue");

        // cutoff: 10 minutes ago
        const cutoff = Timestamp.fromMillis(Date.now() - 10 * 60 * 1000);

        const q = query(
          queueRef,
          where("status", "==", "waiting"),
          orderBy("createdAt", "asc"),
          limit(20)
        );

        const snap = await getDocs(q);

        let opponentDoc = null;

        for (const docSnap of snap.docs) {
          const data = docSnap.data();
          if (!data) continue;

          const createdAt =
            data.createdAt && data.createdAt.toMillis
              ? data.createdAt.toMillis()
              : null;

          // If older than cutoff, delete it and skip
          if (createdAt && createdAt < cutoff.toMillis()) {
            try {
              await deleteDoc(docSnap.ref);
            } catch (e) {
              console.error("Error deleting stale queue entry", e);
            }
            continue;
          }

          // skip myself and any same-client entries for safety
          if (
            docSnap.id !== myQueueRef.id &&
            data.clientId &&
            data.clientId !== myData.clientId
          ) {
            opponentDoc = docSnap;
            break;
          }
        }

        if (!opponentDoc) {
          // nobody else waiting yet
          return;
        }

        const oppData = opponentDoc.data();

        // Create match and update both queue docs in a batch
        const batch = writeBatch(db);
        const matchesRef = collection(db, "headtoheadMatches");
        const matchRef = doc(matchesRef);

        const quizUrl = await getRandomQuizUrl(db);

        batch.set(matchRef, {
          quizUrl,
          status: "active",
          createdAt: serverTimestamp(),
          playerA: {
            clientId: myData.clientId,
            displayName: myData.displayName,
            alias: myData.alias,
          },
          playerB: {
            clientId: oppData.clientId,
            displayName: oppData.displayName,
            alias: oppData.alias,
          },
          scores: {
            playerA: null,
            playerB: null,
          },
          winnerAlias: null,
          loserAlias: null,
          tie: false,
          resolvedAt: null,
          ready: {
            playerA: false,
            playerB: false,
          },
        });

        batch.update(myQueueRef, {
          status: "matched",
          matchId: matchRef.id,
        });

        batch.update(opponentDoc.ref, {
          status: "matched",
          matchId: matchRef.id,
        });

        await batch.commit();
      }

      function renderHeadToHeadResult(match, youData, sideKey) {
        const scores = match.scores || {};
        const myScore = scores[sideKey];
        const oppScore = scores[sideKey === "playerA" ? "playerB" : "playerA"];

        if (!myScore || !oppScore) return; // just in case

        let summary;
        if (match.tie) {
          summary = "This match ended in a tie.";
        } else if (match.winnerAlias === youData.alias) {
          summary = "You won this match!";
        } else if (match.loserAlias === youData.alias) {
          summary = "You lost this match.";
        } else {
          summary = "Match completed.";
        }

        h2hResultSummary.textContent = summary;

        const detailLines = [];
        detailLines.push(
          `Your score: ${myScore.rawScore} (${Math.round(
            myScore.pct * 100
          )}%), time left: ${formatSecondsAsMMSS(myScore.timeLeftSeconds)}`
        );
        detailLines.push(
          `Opponent score: ${oppScore.rawScore} (${Math.round(
            oppScore.pct * 100
          )}%), time left: ${formatSecondsAsMMSS(oppScore.timeLeftSeconds)}`
        );

        h2hResultDetail.innerHTML = "";
        detailLines.forEach((t) => {
          const li = document.createElement("li");
          li.textContent = t;
          h2hResultDetail.appendChild(li);
        });

        h2hResultCard.classList.remove("d-none");
      }

      /**
       * Listen for changes on this user's queue doc.
       * When status becomes 'matched', load the match and show UI.
       */
      function listenForHeadToHeadMatch(db, queueRef, youData) {
        if (h2hQueueUnsub) {
          h2hQueueUnsub();
          h2hQueueUnsub = null;
        }
        h2hQueueUnsub = onSnapshot(queueRef, async (snap) => {
          if (!snap.exists()) {
            setH2HStatus("Your matchmaking request was removed.");
            return;
          }
          const data = snap.data();
          if (data.status === "waiting") {
            setH2HStatus("Waiting for an opponent...");
            return;
          }
          if (data.status === "matched" && data.matchId) {
            if (h2hCancelBtn) h2hCancelBtn.classList.add("d-none");
            clearHeadToHeadQueueTimers();
            setH2HStatus("Match found!");
            const matchRef = doc(db, "headtoheadMatches", data.matchId);
            h2hCurrentMatchRef = matchRef;
            const matchSnap = await getDoc(matchRef);
            if (!matchSnap.exists()) {
              setH2HStatus("Match could not be loaded.");
              return;
            }
            const match = matchSnap.data();
            let opp, sideKey;
            if (match.playerA.clientId === youData.clientId) {
              opp = match.playerB;
              sideKey = "playerA";
            } else {
              opp = match.playerA;
              sideKey = "playerB";
            }
            h2hYouData = youData;
            showH2HMatch(match, youData, opp, sideKey);

            // Also listen to the match document itself for score/result updates
            onSnapshot(matchRef, (mSnap) => {
              if (!mSnap.exists()) return;
              const mData = mSnap.data();

              const scores = mData.scores || {};
              const mySide = sideKey;
              const oppSide = mySide === "playerA" ? "playerB" : "playerA";

              // Show the match & score form once per match
              if (!h2hMatchShownOnce) {
                h2hMatchShownOnce = true;
                showH2HMatch(mData, youData, opp, mySide);
                clearHeadToHeadQueueTimers();
                setH2HStatus(
                  "Match found! Play the quiz and submit your score."
                );
              }

              const myScore = scores[mySide];
              const oppScore = scores[oppSide];

              // Status text for my score
              if (myScore && !mData.winnerAlias && !mData.tie) {
                h2hScoreStatus.textContent =
                  "Score submitted. Waiting for opponent...";
              }

              // When resolved, show final result
              if (
                mData.status === "completed" ||
                mData.winnerAlias ||
                mData.tie
              ) {
                renderHeadToHeadResult(mData, youData, mySide);
              }
            });
          }
        });
      }

      if (h2hScoreForm) {
        h2hScoreForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (!h2hCurrentMatchRef || !h2hCurrentSide || !h2hYouData) {
            h2hScoreStatus.textContent = "No active match.";
            return;
          }
          const parsed = parseScoreString(h2hScoreInput.value);
          if (!parsed) {
            h2hScoreStatus.textContent =
              "Invalid score format. Use num/den, e.g., 10/15.";
            return;
          }
          const seconds = parseTimeString(h2hTimeInput.value);
          if (seconds === null) {
            h2hScoreStatus.textContent =
              "Invalid time. Use mm:ss (e.g., 01:23).";
            return;
          }

          const scoreObj = {
            ...parsed,
            timeLeftSeconds: seconds,
            submittedAt: serverTimestamp(),
          };

          try {
            const fieldPath = `scores.${h2hCurrentSide}`;
            h2hScoreStatus.textContent = "Submitting...";
            await updateDoc(h2hCurrentMatchRef, {
              [fieldPath]: scoreObj,
            });
            h2hScoreStatus.textContent =
              "Score submitted. Waiting for opponent...";
            h2hScoreInput.disabled = true;
            h2hTimeInput.disabled = true;
            document.getElementById("h2h-score-submit-btn").disabled = true;

            // Attempt to resolve match (this is safe via transaction below)
            await resolveHeadToHeadMatch(db, h2hCurrentMatchRef);
          } catch (err) {
            console.error("Error submitting score", err);
            h2hScoreStatus.textContent = "Error submitting score.";
          }
        });
      }

      // Handle form submission
      if (h2hForm) {
        h2hForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (!h2hNameInput.value.trim() || !h2hAliasInput.value.trim()) {
            return;
          }

          const displayName = h2hNameInput.value.trim();
          const alias = h2hAliasInput.value.trim();
          const clientId = getOrCreateHeadToHeadClientId();

          const youData = { displayName, alias, clientId };

          setH2HStatus("Joining matchmaking queue...");
          h2hMatchCard.classList.add("d-none");
          h2hScoreCard.classList.add("d-none");
          h2hResultCard.classList.add("d-none");

          // remove any old "waiting" entries for this client
          await cleanupOldQueueEntries(db, clientId);

          const queueRef = collection(db, "headtoheadQueue");

          // create or replace this client's queue entry
          const myDocRef = await addDoc(queueRef, {
            clientId,
            displayName,
            alias,
            status: "waiting",
            matchId: null,
            createdAt: serverTimestamp(),
          });

          h2hQueueDocRef = myDocRef;
          h2hMatchShownOnce = false;

          if (h2hCancelBtn) h2hCancelBtn.classList.remove("d-none");

          // START the queue timers here:
          startHeadToHeadQueueTimers();

          // start listening and try to match...
          listenForHeadToHeadMatch(db, myDocRef, youData);
          try {
            await tryHeadToHeadMatchmaking(db, myDocRef, youData);
            // do NOT override status in catch; timers are updating it
          } catch (err) {
            console.error("Error during matchmaking", err);
          }
        });
      }

      async function resolveHeadToHeadMatch(db, matchRef) {
        // 1) Read the match once
        const matchSnap = await getDoc(matchRef);
        if (!matchSnap.exists()) return;

        const match = matchSnap.data();
        const scores = match.scores || {};
        const sA = scores.playerA;
        const sB = scores.playerB;

        // Need both scores to resolve
        if (!sA || !sB) return;

        // Already resolved? Do nothing
        if (match.status === "completed" || match.winnerAlias || match.tie) {
          return;
        }

        const pA = match.playerA;
        const pB = match.playerB;

        // 2) Decide winner / loser / tie
        const pctA = sA.pct || 0;
        const pctB = sB.pct || 0;
        const timeA = sA.timeLeftSeconds || 0;
        const timeB = sB.timeLeftSeconds || 0;

        let winnerAlias = null;
        let loserAlias = null;
        let tie = false;

        if (pctA > pctB) {
          winnerAlias = pA.alias;
          loserAlias = pB.alias;
        } else if (pctB > pctA) {
          winnerAlias = pB.alias;
          loserAlias = pA.alias;
        } else {
          // same percent, use time left
          if (timeA > timeB) {
            winnerAlias = pA.alias;
            loserAlias = pB.alias;
          } else if (timeB > timeA) {
            winnerAlias = pB.alias;
            loserAlias = pA.alias;
          } else {
            tie = true;
          }
        }

        // 3) Load existing records for both players
        const recordsRef = collection(db, "headtoheadRecords");
        const refA = doc(recordsRef, pA.alias);
        const refB = doc(recordsRef, pB.alias);

        const [recASnap, recBSnap] = await Promise.all([
          getDoc(refA),
          getDoc(refB),
        ]);

        let recA = recASnap.exists()
          ? recASnap.data()
          : {
              alias: pA.alias,
              displayName: pA.displayName,
              wins: 0,
              losses: 0,
              ties: 0,
              streakType: null, // "W" or "L"
              streakCount: 0,
              bestStreakType: null, // "W" or "L"
              bestStreakCount: 0,
            };

        let recB = recBSnap.exists()
          ? recBSnap.data()
          : {
              alias: pB.alias,
              displayName: pB.displayName,
              wins: 0,
              losses: 0,
              ties: 0,
              streakType: null,
              streakCount: 0,
              bestStreakType: null,
              bestStreakCount: 0,
            };

        // Ensure streak fields exist on old docs
        if (recA.streakType === undefined) recA.streakType = null;
        if (recA.streakCount === undefined) recA.streakCount = 0;
        if (recA.bestStreakType === undefined) recA.bestStreakType = null;
        if (recA.bestStreakCount === undefined) recA.bestStreakCount = 0;

        if (recB.streakType === undefined) recB.streakType = null;
        if (recB.streakCount === undefined) recB.streakCount = 0;
        if (recB.bestStreakType === undefined) recB.bestStreakType = null;
        if (recB.bestStreakCount === undefined) recB.bestStreakCount = 0;

        // 4) Update their records in memory
        if (tie) {
          recA.ties = (recA.ties || 0) + 1;
          recB.ties = (recB.ties || 0) + 1;
        } else {
          if (winnerAlias === pA.alias) {
            // A wins, B loses
            recA.wins = (recA.wins || 0) + 1;
            recB.losses = (recB.losses || 0) + 1;

            // A current streak (wins)
            if (recA.streakType === "W") {
              recA.streakCount = (recA.streakCount || 0) + 1;
            } else {
              recA.streakType = "W";
              recA.streakCount = 1;
            }

            // B current streak (losses)
            if (recB.streakType === "L") {
              recB.streakCount = (recB.streakCount || 0) + 1;
            } else {
              recB.streakType = "L";
              recB.streakCount = 1;
            }

            // BEST streak: only track BEST WIN streaks
            if (
              recA.streakType === "W" &&
              recA.streakCount > (recA.bestStreakCount || 0)
            ) {
              recA.bestStreakType = "W";
              recA.bestStreakCount = recA.streakCount;
            }
            // Do NOT update best streak for B on losses
          } else {
            // B wins, A loses
            recB.wins = (recB.wins || 0) + 1;
            recA.losses = (recA.losses || 0) + 1;

            if (recB.streakType === "W") {
              recB.streakCount = (recB.streakCount || 0) + 1;
            } else {
              recB.streakType = "W";
              recB.streakCount = 1;
            }

            if (recA.streakType === "L") {
              recA.streakCount = (recA.streakCount || 0) + 1;
            } else {
              recA.streakType = "L";
              recA.streakCount = 1;
            }

            if (
              recB.streakType === "W" &&
              recB.streakCount > (recB.bestStreakCount || 0)
            ) {
              recB.bestStreakType = "W";
              recB.bestStreakCount = recB.streakCount;
            }
            // Do NOT update best streak for A on losses
          }
        }

        // 5) Write everything in one batch
        const batch = writeBatch(db);

        const matchUpdate = {
          status: "completed",
          resolvedAt: serverTimestamp(),
          tie,
        };
        if (!tie) {
          matchUpdate.winnerAlias = winnerAlias;
          matchUpdate.loserAlias = loserAlias;
        }

        batch.update(matchRef, matchUpdate);
        batch.set(refA, recA, { merge: true });
        batch.set(refB, recB, { merge: true });

        await batch.commit();
      }

      function renderHeadToHeadStandings(rows) {
        if (!h2hStandingsBody) return;
        h2hStandingsBody.innerHTML = "";

        // compute win pct & games
        // compute games and win% (still useful to show)
        rows.forEach((r) => {
          const w = r.wins || 0;
          const l = r.losses || 0;
          const t = r.ties || 0; // kept for compatibility, but not used in % now

          // Win% is based ONLY on wins + losses
          const wlGames = w + l;
          r.games = wlGames; // use this for the Win% denominator
          r.winPct = wlGames > 0 ? w / wlGames : 0;
        });

        // sort: more wins first, then higher win%, then fewer games, then alias
        rows.sort((a, b) => {
          if ((b.wins || 0) !== (a.wins || 0))
            return (b.wins || 0) - (a.wins || 0);
          if ((b.winPct || 0) !== (a.winPct || 0))
            return (b.winPct || 0) - (a.winPct || 0);
          if ((a.games || 0) !== (b.games || 0))
            return (a.games || 0) - (b.games || 0);
          return (a.alias || "").localeCompare(b.alias || "");
        });

        rows.forEach((r, idx) => {
          const tr = document.createElement("tr");
          const winPctStr =
            r.games > 0 ? (r.winPct * 100).toFixed(1) + "%" : "â€“";

          const streakType = r.streakType || null;
          const streakCount = r.streakCount || 0;
          const streakLabel =
            streakType && streakCount > 0 ? `${streakType}${streakCount}` : "â€“";

          const bestType = r.bestStreakType || null;
          const bestCount = r.bestStreakCount || 0;
          const bestLabel =
            bestType === "W" && bestCount > 0 ? `W${bestCount}` : "â€“";

          tr.innerHTML = `
    <td>${idx + 1}</td>
    <td>${r.displayName || ""}</td>
    <td>${r.alias || ""}</td>
    <td>${r.wins || 0}</td>
    <td>${r.losses || 0}</td>
    <td>${streakLabel}</td>
    <td>${bestLabel}</td>
    <td>${winPctStr}</td>
  `;
          h2hStandingsBody.appendChild(tr);
        });
      }

      // Subscribe to records
      (function subscribeHeadToHeadStandings() {
        const ref = collection(db, "headtoheadRecords");
        onSnapshot(ref, (snap) => {
          const rows = [];
          snap.forEach((d) => {
            rows.push({ id: d.id, ...(d.data() || {}) });
          });
          renderHeadToHeadStandings(rows);
        });
      })();
    </script>

    <!-- Bootstrap JS bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Your app logic -->
    <script src="app.js" defer></script>
  </body>
</html>
